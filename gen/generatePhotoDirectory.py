# python 3
#
# look at all photo gallery pages on disk, and create a single
#   "directory" page (with nice collapsible sections?) to
#   navigate to them all
#

from hashlib import sha256
from io import StringIO
from pathlib import Path
import re
import sys

def write_page_link(*, SITE_ROOT_REL, section, children, child_name, buffer, bullet_depth):
	child = children[child_name]
	page_name = child.stem.replace('-', ' ').title()
	if child_name in section['rename']:
		page_name = section['rename'][child_name]
	buffer.write(f"{' ' * ((bullet_depth-1)*2)}* [{page_name}]({SITE_ROOT_REL}/{section['dir']}/{child.stem}.html)\n")

# for now, just open the file a second time if a write is needed
def overwrite_file_if_changed(*, file_path, new_contents_bytes):
	if file_path.is_file():
		with open(file_path, mode="rb") as f:
			file_contents_hash = sha256(f.read()).hexdigest()

			# if the hash of the contents is different than what's already
			#   on disk, write to disk
			new_contents_hash = sha256(new_contents_bytes).hexdigest()

			if file_contents_hash == new_contents_hash:
				return False

	print(f'writing changed contents into file [{file_path}]')
	with open(file_path, mode="wb") as f:
		f.write(new_contents_bytes)
	return True

def build(*, SITE_ROOT_REL, static_gen_path):

	#SITE_ROOT_REL=sys.argv[1]

	directory_md_path = static_gen_path.joinpath("photo-galleries.md")

	sections = {
		"Birds": {
			"dir": "birds",
			"rename": {
				"index": "All Birds I've Photographed",
				"home": "All Birds I've Photographed at my Oregon Home"
			},
			"subsections": [
				{ 'title': "Birds I've Photographed", 'patt': re.compile(r'2[0-9]{3}\.md'), 'nonpatt': ["index.md"] },
				{ 'title': "Favorites", 'patt': re.compile(r'favorites-2[0-9]{3}\.md'), 'nonpatt': [] },
				{ 'title': "At my Oregon Home", 'patt': re.compile(r'home-2[0-9]{3}\.md'), 'nonpatt': ["home.md"] }
			]
		},
		"All Other Favorites by Year": {
			"dir": "photos",
			"rename": {
			}
			# for dirs without logical sub-sections, we can move a
			#   specified file name to first in the list
			#"first": "index",
		}
	}

	directory_md_buf = StringIO()

	directory_md_buf.write(f"""
<!-- this file is generated by generatePhotoDirectory.py -->

[//]: # (gen-title: Photo Galleries Directory)

[//]: # (gen-keywords: photography, gallery, birds, birding, wildlife, landscape, art)

[//]: # (gen-description: Links to all photo gallery pages)

[//]: # (gen-meta-end)

<style>
	div.wrap-wider-child img {{
		border: 0.2rem solid white;
		padding: 0;
		margin: 0 0 0 -0.2rem;
	}}
	@media screen and (min-width: 32rem) {{
		div.wrap-wider-child img {{
			border: 0.4rem solid white;
			padding: 0;
			margin: 0 0 0 -0.4rem;
		}}
	}}
	@media screen and (min-width: 63rem) {{
		div.wrap-wider-child img {{
			border: 0.7rem solid white;
			padding: 0;
			margin: 0;
		}}
	}}
</style>

# Photo Galleries

<div class="wrap-wider-child">
	<img class="width-100" src="{SITE_ROOT_REL}/s/img/2022/2022-09-01-193511-19-R6PT0790-photoshop-biggerthumb-sm.jpg"/>
</div>

## Latest

* [My Latest Gallery]({SITE_ROOT_REL}/gallery/)

	""")

	for section in sections:
		directory_md_buf.write(f"\n## {section}\n")

		section_path = static_gen_path.joinpath(sections[section]['dir'])
		children = {}
		for child in section_path.iterdir():
			if child.suffix != ".md":
				continue
			children[child.stem] = child
		sorted_children = list(reversed(sorted(children.keys())))

		if 'subsections' in sections[section]:
			for subsection in sections[section]['subsections']:
				directory_md_buf.write(f"* {subsection['title']}\n")
				# first, create links for any non-pattern matches, in order
				nonpatt_matches = set()
				for nonpatt_filename in subsection['nonpatt']:
					for child_name in sorted_children:
						if children[child_name].name == nonpatt_filename:
							nonpatt_matches.add(children[child_name].name)
							write_page_link(SITE_ROOT_REL=SITE_ROOT_REL, section=sections[section], children=children, child_name=child_name, buffer=directory_md_buf, bullet_depth=2)
				# next, create links for files that match the pattern specified
				#   for this subsection
				pattern = subsection['patt']
				for child_name in sorted_children:
					if children[child_name].name in nonpatt_matches:
						continue
					if pattern.fullmatch(children[child_name].name) is None:
						continue
					write_page_link(SITE_ROOT_REL=SITE_ROOT_REL, section=sections[section], children=children, child_name=child_name, buffer=directory_md_buf, bullet_depth=2)
		else:
			if "first" in sections[section]:
				first = sections[section]['first']
				sorted_children.remove(first)
				sorted_children.insert(0, first)

			for child_name in sorted_children:
				write_page_link(SITE_ROOT_REL=SITE_ROOT_REL, section=sections[section], children=children, child_name=child_name, buffer=directory_md_buf, bullet_depth=1)
				#child = children[child_name]
				#page_name = child.stem.replace('-', ' ').title()
				#if child_name in sections[section]['rename']:
				#	page_name = sections[section]['rename'][child_name]
				#directory_md_buf.write(f"* [{page_name}]({SITE_ROOT_REL}/{sections[section]['dir']}/{child.stem}.html)\n")
		directory_md_buf.write("\n")

	# write new directory markdown file content, only if it needs to be changed
	overwrite_file_if_changed(
		file_path=directory_md_path,
		new_contents_bytes=directory_md_buf.getvalue().encode('utf-8', 'ignore'))
