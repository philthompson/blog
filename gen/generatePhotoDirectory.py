# python 3
#
# look at all photo gallery pages on disk, and create a single
#   "directory" page (with nice collapsible sections?) to
#   navigate to them all
#

from hashlib import sha256
from io import StringIO
from pathlib import Path
import re
import sys

if len(sys.argv) < 2:
	print(f"usage: {sys.argv[0]} <SITE_ROOT_REL>", file=sys.stderr)
	sys.exit(1)

SITE_ROOT_REL=sys.argv[1]

static_gen_path = Path(__file__).parent.joinpath("static")

directory_md_path = static_gen_path.joinpath("photo-galleries.md")

sections = {
	"Birds": {
		"dir": "birds",
		"rename": {
			"index": "All Birds I've Photographed",
			"home": "All Birds I've Photographed at my Oregon Home"
		},
		"subsections": [
			{ 'title': "Birds I've Photographed", 'patt': re.compile('2[0-9]{3}\.md'), 'nonpatt': ["index.md"] },
			{ 'title': "Favorites", 'patt': re.compile('favorites-2[0-9]{3}\.md'), 'nonpatt': [] },
			{ 'title': "At my Oregon Home", 'patt': re.compile('home-2[0-9]{3}\.md'), 'nonpatt': ["home.md"] }
		]
	},
	"All Other Photos": {
		"dir": "photos",
		"rename": {
		}
		# for dirs without logical sub-sections, we can move a
		#   specified file name to first in the list
		#"first": "index",
	}
}

directory_md_buf = StringIO()

directory_md_buf.write(f"""
<!-- this file is generated by generatePhotoDirectory.py -->

[//]: # (gen-title: Photo Galleries Directory)

[//]: # (gen-keywords: photography, gallery, birds, birding, wildlife, landscape, art)

[//]: # (gen-description: Links to all photo gallery pages)

[//]: # (gen-meta-end)

# Photo Galleries

<div class="wrap-wider-child">
	<img class="width-100" style="border: 0.7rem solid white; padding: 0; margin: 0;" src="{SITE_ROOT_REL}/s/img/2022/2022-09-01-193511-19-R6PT0790-photoshop-biggerthumb-sm.jpg"/>
</div>

## Latest

* [My Latest Gallery]({SITE_ROOT_REL}/gallery/)

""")

def write_page_link(*, children, child_name, buffer, bullet_depth):
	global sections
	child = children[child_name]
	page_name = child.stem.replace('-', ' ').title()
	if child_name in sections[section]['rename']:
		page_name = sections[section]['rename'][child_name]
	buffer.write(f"{' ' * ((bullet_depth-1)*2)}* [{page_name}]({SITE_ROOT_REL}/{sections[section]['dir']}/{child.stem}.html)\n")

for section in sections:
	directory_md_buf.write(f"""
## {section}
""")

	section_path = static_gen_path.joinpath(sections[section]['dir'])
	children = {}
	for child in section_path.iterdir():
		if child.suffix != ".md":
			continue
		children[child.stem] = child
	sorted_children = list(reversed(sorted(children.keys())))

	if 'subsections' in sections[section]:
		for subsection in sections[section]['subsections']:
			directory_md_buf.write(f"* {subsection['title']}\n")
			# first, create links for any non-pattern matches, in order
			nonpatt_matches = set()
			for nonpatt_filename in subsection['nonpatt']:
				for child_name in sorted_children:
					if children[child_name].name == nonpatt_filename:
						nonpatt_matches.add(children[child_name].name)
						write_page_link(children=children, child_name=child_name, buffer=directory_md_buf, bullet_depth=2)
			# next, create links for files that match the pattern specified
			#   for this subsection
			pattern = subsection['patt']
			for child_name in sorted_children:
				if children[child_name].name in nonpatt_matches:
					continue
				if pattern.fullmatch(children[child_name].name) is None:
					continue
				write_page_link(children=children, child_name=child_name, buffer=directory_md_buf, bullet_depth=2)
	else:
		if "first" in sections[section]:
			first = sections[section]['first']
			sorted_children.remove(first)
			sorted_children.insert(0, first)

		for child_name in sorted_children:
			write_page_link(children=children, child_name=child_name, buffer=directory_md_buf, bullet_depth=1)
			#child = children[child_name]
			#page_name = child.stem.replace('-', ' ').title()
			#if child_name in sections[section]['rename']:
			#	page_name = sections[section]['rename'][child_name]
			#directory_md_buf.write(f"* [{page_name}]({SITE_ROOT_REL}/{sections[section]['dir']}/{child.stem}.html)\n")
	directory_md_buf.write("\n")


# for now, just open the file a second time if a write is needed
def overwrite_file_if_changed(*, file_path, new_contents_bytes):
	if file_path.is_file():
		with open(file_path, mode="rb") as f:
			file_contents_hash = sha256(f.read()).hexdigest()

			# if the hash of the contents is different than what's already
			#   on disk, write to disk
			new_contents_hash = sha256(new_contents_bytes).hexdigest()

			if file_contents_hash == new_contents_hash:
				return False

	print(f'writing changed contents into file [{file_path}]')
	with open(file_path, mode="wb") as f:
		f.write(new_contents_bytes)
	return True

# write new directory markdown file content, only if it needs to be changed
overwrite_file_if_changed(
	file_path=directory_md_path,
	new_contents_bytes=directory_md_buf.getvalue().encode('utf-8', 'ignore'))
