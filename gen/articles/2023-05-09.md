
<!-- Copyright 2023 Phil Thompson. All Rights Reserved.  As noted in the License section of this repository's readme.md file, this file and its corresponding public HTML file, and all other articles, article files, and images, are distributed under traditional copyright.  The repository source code and other files are distributed under the MIT license. -->

[//]: # (gen-title: Faster Mandelbrot Set Rendering with BLA: Bivariate Linear Approximation)

[//]: # (gen-title-url: Faster-Mandelbrot-Set-Rendering-with-BLA-Bivariate-Linear-Approximation)

[//]: # (gen-keywords: javascript, fractal, mandelbrot set, perturbation theory, bla, bivariate linear approximation, very plotter)

[//]: # (gen-description: Discussion on the implementation of bivariate linear approximation for Very Plotter's Mandelbrot set viewer.)

[//]: # (gen-meta-end)

<a href="${THIS_ARTICLE}"><img style="float: left" class="width-resp-50-100" src="${SITE_ROOT_REL}/img/20230509.jpg"/></a> 

The latest and greatest (as of the time of writing, in May 2023) method for computing Mandelbrot set images is a form of bivariate linear approximation, which is referred to as BLA.  Discussion of this method began in late 2021 on the fractalforums.org site (from the <a target="_blank" href="https://fractalforums.org/index.php?topic=4360.30">first post on page 3 of this thread</a>).  I made some failed attempts to implement BLA in 2022, but over the last few months I've finally got an experimental BLA working in my JavaScript Mandelbrot set viewer, <a href="${SITE_ROOT_REL}/very-plotter/">Very Plotter</a>.

In this post I'll show how to use BLA in the Very Plotter <a target="_blank" href="https://github.com/philthompson/visualize-primes/releases/tag/v0.10.0">v0.10.0 release</a>.  Then, I'll give some background on the theory and implementation of BLA, and show the performance I'm seeing at some example locations.

[more](more://)

## Using BLA in Very Plotter

Before describing BLA itself, I'll show how to use it in Very Plotter, and what to expect.

As of Very Plotter v0.10.0, BLA should be considered an "experimental" feature.  It works for many locations, but some locations have no acceleration provided by BLA and would be better viewed with plain perturbation theory or perturbation with series approximation.

To enable BLA in Very Plotter, open the controls menu (with the wrench icon) and expand the "algorithm options" pane.  There, you'll find an "automatic with BLA" setting in the options dropdown list.  Select that, and click the "Go" button.

With that "algorithm" active, BLA will be enabled once a sufficiently deep location is rendered (where the scale is greater than 1e25 pixels per unit).

When a BLA render starts, the following steps occur:

1. An on-screen minibrot nucleus is located
1. A reference orbit is calculated for a point in that nucleus
1. An <math style="font-size:1.2rem"><mi>ε</mi></math> (epsilon) value is found
1. BLAs are calculated using the <math style="font-size:1.2rem"><mi>ε</mi></math>
1. Each pixel is computed using BLA, where iterations can be skipped, and using perturbation theory where individual iterations have no valid BLA

The first three steps above can take some time, during which the render window will show only status updates, and no actual rendered pixels.  For very deep locations, those initial steps can take several minutes (or even hours, but for those locations you're much better off using a proper desktop Mandelbrot set viewer).

For some locations, the above step 1 currently fails.  If a nucleus cannot be found, a periodic point cannot be found, and the middle of screen is used for the reference orbit point instead.  This works fine for perturbation theory and for series approximation, but for my BLA implementation this slows things down considerably.

If, however, you are rendering a location with a found on-screen nucleus, you can use the R key to toggle on the mouse position display.  You'll also see an "X" shape drawn on the found periodic point within a nucleus.  If you draw a zoom box (hold alt/option and drag the mouse) that contains that point, steps 1 and 2 above can be skipped for the new zoomed-in location and rendering of the new location will start quickly.  You can also re-use the reference orbit point by changing the scale or magnification in the "go to location by center and scale" pane in the controls menu.

## Finding A Periodic Point

If we can find a periodic point on screen, then the reference orbit can be computed only for the period (since it repeats).  Also, we will compute and merge fewer BLAs associated with that period-shortened reference orbit (more on that later).  This significantly increases the overall speed with which we can find valid BLAs when computing each pixel (again, more on this later).  So therefore, for performance reasons, it's worth taking the time to find an on-screen periodic point.

All points in the interior of the Mandelbrot set are periodic (by definition) so all we need to do is find a minibrot (or "<a target="_blank" href="https://www.mrob.com/pub/muency/islandmumolecule.html">mu-molecule</a>") which luckily is a relatively straightforward, repeatable procedure:

1. Find the dominant period ("<a target="_blank" href="https://www.mrob.com/pub/muency/atomdomain.html">atom domain</a>") of the window
1. Use the period in calculating <a target="_blank" href="https://en.wikipedia.org/wiki/Newton%27s_method">Newton's method</a> iterations to get progressively closer to the minibrot
1. If the minibrot is on-screen, we are done, otherwise, go back to step 1 to find a "deeper" higher-period minibrot

There are a few period-finding algorithms.  One method involves iterating the points of a polygon (see "Finding the Period of a mu-Atom" <a target="_blank" href="https://www.mrob.com/pub/muency/period.html">on this page</a>) but a faster method is the "ball arithmetic" method.  I don't understand the math myself, but I was able to implement the method using the <a target="_blank" href="https://fractalforums.org/index.php?topic=3805.msg24312#msg24312">pseudocode from gerrit's post here</a>.  The "2nd order" algorithm ran too slowly for me, so I just use the "1st order" one.  For the `dx` and `dy` parameters, I use the distance from the center of the screen to the edge of the screen, along the x and y axis respectively, which causes the algorithm to search within the largest possible circle that fits in the window being rendered.  Step 3 above uses the `doCont` condition in the algorithm: continue iterating to find a deeper and higher period domain within the window.

Really helpful pseudocode for Newton's method was <a target="_blank" href="https://www.fractalforums.com/index.php?topic=18289.msg90972#msg90972">posted by claude here</a>.  To determine when Newton's method "starts to converge" I implemented an "approximately equals" method for my arbitrary precision numbers, which compares some number of most-significant digits.

Once we have a periodic point, we can compute only one period's worth of iterations for a reference orbit at that point.

## Calculating the BLA Coefficients

Once we have our reference orbit, calculated with full precision, we can calculate a set of BLAs for it, where for each iteration <math style="font-size:1.2rem"><mi>m</mi></math> in the reference orbit we can calculate coefficients <math style="font-size:1.2rem"><msub><mi>A</mi><mn>l</mn></msub></math> and <math style="font-size:1.2rem"><msub><mi>B</mi><mn>l</mn></msub></math> that allow us to skip ahead <math style="font-size:1.2rem"><mi>l</mi></math> iterations.

Zhuoran provided an overview of the idea, with some nicely-formatted math, in <a target="_blank" href="https://fractalforums.org/index.php?topic=4360.msg31806#msg31806">this post</a>.  I ended up using their initial values and formulas for <math style="font-size:1.2rem"><msub><mi>A</mi><mn>0</mn></msub><mo>,</mo><msub><mi>B</mi><mn>0</mn></msub><mo>,</mo><msub><mi>A</mi><mn>1</mn></msub><mo>,</mo><msub><mi>B</mi><mn>1</mn></msub></math> but not the generalized <math style="font-size:1.2rem"><msub><mi>A</mi><mi>l</mi></msub></math> and <math style="font-size:1.2rem"><msub><mi>B</mi><mi>l</mi></msub></math>.

How many iterations do we skip?  Recall that in perturbation theory, we can iterate our low-precision <math style="font-size:1.2rem"><mn>Δ</mn><mi>z</mi></math> with:

<math display="block" style="font-size:1.5rem">
  <msub>
    <mrow>
      <mn>Δ</mn>
      <mi>z</mi>
    </mrow>
    <mi>n+1</mi>
  </msub>
  <mo>=</mo>
  <mn>2</mn>
  <msub>
    <mi>Z</mi>
    <mi>n</mi>
  </msub>
  <msub>
    <mrow>
      <mn>Δ</mn>
      <mi>z</mi>
    </mrow>
    <mi>n</mi>
  </msub>
  <mo>+</mo>
  <msubsup>
    <mrow>
      <mn>Δ</mn>
      <mi>z</mi>
    </mrow>
    <mi>n</mi>
    <mn>2</mn>
  </msubsup>
  <mo>+</mo>
  <mrow>
    <mn>Δ</mn>
    <mi>c</mi>
  </mrow>
</math>
<math display="block" style="font-size:1.5rem">
  <mrow>
    <mtext><small>where</small></mtext>
  </mrow>
</math>
<math display="block" style="font-size:1.5rem">
  <mrow>
    <msub>
      <mi>Z</mi>
      <mi>n</mi>
    </msub>
    <mo>=</mo>
    <mtext><small>reference orbit at iteration&nbsp;</small></mtext>
    <mi>n</mi>
  </mrow>
</math>
<math display="block" style="font-size:1.5rem">
  <mrow>
    <msub>
      <mi>z</mi>
      <mi>n</mi>
    </msub>
    <mo>=</mo>
    <mtext><small>pixel orbit at iteration&nbsp;</small></mtext>
    <mi>n</mi>
  </mrow>
</math>
<math display="block" style="font-size:1.5rem">
  <mrow>
    <msub>
      <mrow>
        <mn>Δ</mn>
        <mi>z</mi>
      </mrow>
      <mi>n</mi>
    </msub>
    <mo>=</mo>
    <msub>
      <mi>Z</mi>
      <mi>n</mi>
    </msub>
    <mo>-</mo>
    <msub>
      <mi>z</mi>
      <mi>n</mi>
    </msub>
  </mrow>
</math>
<math display="block" style="font-size:1.5rem">
  <mrow>
    <msub>
      <mn>Δ</mn>
      <mi>c</mi>
    </msub>
    <mo>=</mo>
    <msub>
      <mi>C</mi>
      <mtext>reference</mtext>
    </msub>
    <mo>-</mo>
    <msub>
      <mi>c</mi>
      <mtext>pixel</mtext>
    </msub>
  </mrow>
</math>

The central idea of BLA is that if the squared term <math style="font-size:1.2rem"><msubsup><mrow><mn>Δ</mn><mi>z</mi></mrow><mi>n</mi><mn>2</mn></msubsup></math> is small enough, it will have no effect on the result of the computation.  In that case, we can *remove* that squared term leaving a linear iteration equation.  Since the equation is then linear, we can combine many iterations of that linear equation into one equivalent equation that performs many iterations in one computation.

To demonstrate the idea, at least for JavaScript, we can see that:

	# this works
	5 + 5e-15 === 5.000000000000005
	# this is starting to exceed JavaScript's floating-point precision
    5 + 5e-16 === 5.000000000000001
    # now we are adding a value small enough to be negligible
    5 + 4e-16 === 5

How can we quantify a "small enough" value for the squared term?  To start with, we'll use a "smallness" factor <math style="font-size:1.2rem"><mi>ε</mi></math> (epsilon),  where the squared term is considered "small enough" if less than the non-squared term by more than that <math style="font-size:1.2rem"><mi>ε</mi></math> factor:

<math display="block" style="font-size:1.5rem">
  <mo lspace="0" rspace="0">|</mo>
  <msubsup>
    <mrow>
      <mn>Δ</mn>
      <mi>z</mi>
    </mrow>
    <mi>n</mi>
    <mn>2</mn>
  </msubsup>
  <mo lspace="0" rspace="0">|</mo>
  <mo><</mo>
  <mi>ε</mi>
  <mo lspace="0" rspace="0">|</mo>
  <mn>2</mn>
  <msub>
    <mi>Z</mi>
    <mi>n</mi>
  </msub>
  <msub>
    <mrow>
      <mn>Δ</mn>
      <mi>z</mi>
    </mrow>
    <mi>n</mi>
  </msub>
  <mo lspace="0" rspace="0">|</mo>
</math>

Going back to the perturbation equation, but without the squared term, we have:

<math display="block" style="font-size:1.5rem">
  <msub>
    <mrow>
      <mn>Δ</mn>
      <mi>z</mi>
    </mrow>
    <mi>n+1</mi>
  </msub>
  <mo>=</mo>
  <mn>2</mn>
  <msub>
    <mi>Z</mi>
    <mi>n</mi>
  </msub>
  <msub>
    <mrow>
      <mn>Δ</mn>
      <mi>z</mi>
    </mrow>
    <mi>n</mi>
  </msub>
  <mo>+</mo>
  <mrow>
    <mn>Δ</mn>
    <mi>c</mi>
  </mrow>
</math>

Where (again, according to <a target="_blank" href="https://fractalforums.org/index.php?topic=4360.msg31806#msg31806">Zhuoran's post</a>) we can generalize many invocations of that equation to skip <math style="font-size:1.2rem"><mi>l</mi></math> iterations beyond the <math style="font-size:1.2rem"><mi>m</mi><mtext>th</mtext></math> iteration to get to iteration <math style="font-size:1.2rem"><mi>n</mi><mo>=</mo><mi>m</mi><mo>+</mo><mi>l</mi></math> using two coefficients <math style="font-size:1.2rem"><msub><mi>A</mi><mi>l</mi></msub></math> and <math style="font-size:1.2rem"><msub><mi>B</mi><mi>l</mi></msub></math>:

<math display="block" style="font-size:1.5rem">
  <msub>
    <mrow>
      <mn>Δ</mn>
      <mi>z</mi>
    </mrow>
    <mi>n</mi>
  </msub>
  <mo>=</mo>
  <msub>
    <mi>A</mi>
    <mi>l</mi>
  </msub>
  <msub>
    <mrow>
      <mn>Δ</mn>
      <mi>z</mi>
    </mrow>
    <mi>m</mi>
  </msub>
  <mo>+</mo>
  <msub>
    <mi>B</mi>
    <mi>l</mi>
  </msub>
  <mrow>
    <mn>Δ</mn>
    <mi>c</mi>
  </mrow>
</math>
<math display="block" style="font-size:1.5rem">
  <mrow>
    <mtext><small>where</small></mtext>
  </mrow>
</math>
<math display="block" style="font-size:1.5rem">
  <mrow>
    <msub>
      <mi>n</mi>
      <mtext>result</mtext>
    </msub>
    <mo>=</mo>
    <msub>
      <mi>m</mi>
      <mtext>start</mtext>
    </msub>
    <mo>+</mo>
    <msub>
      <mi>l</mi>
      <mtext>skip</mtext>
    </msub>
  </mrow>
</math>

To find these coefficients for "skipping" 1 iteration, we can look at the linear-ized perturbation equation and the bivariate linear approximation equation.  Since a BLA "skip" of 1 iteration must be equivalent to a regular perturbation iteration, we can see that the coefficients must be <math style="font-size:1.2rem"><msub><mi>A</mi><mn>1</mn></msub><mo>=</mo><mn>2</mn><mi>Z</mi></math> and <math style="font-size:1.2rem"><msub><mi>B</mi><mn>1</mn></msub><mo>=</mo><mn>1</mn></math>:

<math display="block" style="font-size:1.5rem; padding-bottom:0.5rem">
  <mrow>
    <mtext><small>perturbation:</small></mtext>
  </mrow>
</math>
<math display="block" style="font-size:1.5rem; padding-bottom:0.5rem">
  <msub>
    <mrow>
      <mn>Δ</mn>
      <mi>z</mi>
    </mrow>
    <mi>n</mi>
  </msub>
  <mo>=</mo>
  <mn>2</mn>
  <msub>
    <mi>Z</mi>
    <mi>m</mi>
  </msub>
  <msub>
    <mrow>
      <mn>Δ</mn>
      <mi>z</mi>
    </mrow>
    <mi>m</mi>
  </msub>
  <mo>+</mo>
  <mrow>
    <mn>Δ</mn>
    <mi>c</mi>
  </mrow>
</math>
<math display="block" style="font-size:1.5rem; padding-bottom:0.5rem">
  <mrow>
    <mtext><small>BLA:</small></mtext>
  </mrow>
</math>
<math display="block" style="font-size:1.5rem; padding-bottom:0.5rem">
  <msub>
    <mrow>
      <mn>Δ</mn>
      <mi>z</mi>
    </mrow>
    <mi>n</mi>
  </msub>
  <mo>=</mo>
  <mo>(</mo>
  <msub>
    <mi>A</mi>
    <mi>l</mi>
  </msub>
  <mo>)</mo>
  <msub>
    <mrow>
      <mn>Δ</mn>
      <mi>z</mi>
    </mrow>
    <mi>m</mi>
  </msub>
  <mo>+</mo>
  <mo>(</mo>
  <msub>
    <mi>B</mi>
    <mi>l</mi>
  </msub>
  <mo>)</mo>
  <mrow>
    <mn>Δ</mn>
    <mi>c</mi>
  </mrow>
</math>
<math display="block" style="font-size:1.5rem; padding-bottom:0.5rem">
  <mrow>
    <mtext><small>therefore:</small></mtext>
  </mrow>
</math>
<math display="block" style="font-size:1.5rem; padding-bottom:0.5rem">
  <mrow>
    <msub>
      <mi>A</mi>
      <mn>1</mn>
    </msub>
    <mo>=</mo>
    <mn>2</mn>
    <mi>Z</mi>
  </mrow>
</math>
<math display="block" style="font-size:1.5rem; padding-bottom:0.5rem">
  <mrow>
    <msub>
      <mi>B</mi>
      <mn>1</mn>
    </msub>
    <mo>=</mo>
    <mn>1</mn>
  </mrow>
</math>
<math display="block" style="font-size:1.5rem">
  <msub>
    <mrow>
      <mn>Δ</mn>
      <mi>z</mi>
    </mrow>
    <mi>n</mi>
  </msub>
  <mo>=</mo>
  <mo>(</mo>
  <mn>2</mn>
  <msub>
    <mi>Z</mi>
    <mi>n</mi>
  </msub>
  <mo>)</mo>
  <msub>
    <mrow>
      <mn>Δ</mn>
      <mi>z</mi>
    </mrow>
    <mi>m</mi>
  </msub>
  <mo>+</mo>
  <mo>(</mo>
  <mn>1</mn>
  <mo>)</mo>
  <mrow>
    <mn>Δ</mn>
    <mi>c</mi>
  </mrow>
</math>

Next, we can put our above "small enough" validity check in terms of these coefficients.  Notice that since <math style="font-size:1.2rem"><mi>ε</mi></math> is some unknown quantity anyway we can roll the <math style="font-size:1.2rem"><mn>2</mn></math> value into <math style="font-size:1.2rem"><mi>ε</mi></math>:

<math display="block" style="font-size:1.5rem; padding-bottom:0.5rem">
  <mo lspace="0" rspace="0">|</mo>
  <msubsup>
    <mrow>
      <mn>Δ</mn>
      <mi>z</mi>
    </mrow>
    <mi>n</mi>
    <mn>2</mn>
  </msubsup>
  <mo lspace="0" rspace="0">|</mo>
  <mo><</mo>
  <mi>ε</mi>
  <mo lspace="0" rspace="0">|</mo>
  <mn>2</mn>
  <msub>
    <mi>Z</mi>
    <mi>n</mi>
  </msub>
  <msub>
    <mrow>
      <mn>Δ</mn>
      <mi>z</mi>
    </mrow>
    <mi>n</mi>
  </msub>
  <mo lspace="0" rspace="0">|</mo>
</math>
<math display="block" style="font-size:1.5rem; padding-bottom:0.5rem">
  <mo lspace="0" rspace="0">|</mo>
  <msub>
    <mrow>
      <mn>Δ</mn>
      <mi>z</mi>
    </mrow>
    <mi>n</mi>
  </msub>
  <mo lspace="0" rspace="0">|</mo>
  <mo><</mo>
  <mi>ε</mi>
  <mo lspace="0" rspace="0">|</mo>
  <mn>2</mn>
  <msub>
    <mi>Z</mi>
    <mi>n</mi>
  </msub>
  <mo lspace="0" rspace="0">|</mo>
</math>
<math display="block" style="font-size:1.5rem; padding-bottom:0.5rem">
  <mo lspace="0" rspace="0">|</mo>
  <msub>
    <mrow>
      <mn>Δ</mn>
      <mi>z</mi>
    </mrow>
    <mi>n</mi>
  </msub>
  <mo lspace="0" rspace="0">|</mo>
  <mo><</mo>
  <mi>ε</mi>
  <mo lspace="0" rspace="0">|</mo>
  <msub>
    <mi>Z</mi>
    <mi>n</mi>
  </msub>
  <mo lspace="0" rspace="0">|</mo>
</math>

Then since:

<math display="block" style="font-size:1.5rem">
  <msub>
    <mrow>
      <mn>Δ</mn>
      <mi>z</mi>
    </mrow>
    <mi>n</mi>
  </msub>
  <mo>=</mo>
  <msub>
    <mi>A</mi>
    <mi>l</mi>
  </msub>
  <msub>
    <mrow>
      <mn>Δ</mn>
      <mi>z</mi>
    </mrow>
    <mi>m</mi>
  </msub>
  <mo>+</mo>
  <msub>
    <mi>B</mi>
    <mi>l</mi>
  </msub>
  <mrow>
    <mn>Δ</mn>
    <mi>c</mi>
  </mrow>
</math>

We can substitute that in above:

<math display="block" style="font-size:1.5rem; padding-bottom:0.5rem">
  <mo lspace="0" rspace="0">|</mo>
  <msub>
    <mi>A</mi>
    <mi>l</mi>
  </msub>
  <msub>
    <mrow>
      <mn>Δ</mn>
      <mi>z</mi>
    </mrow>
    <mi>m</mi>
  </msub>
  <mo>+</mo>
  <msub>
    <mi>B</mi>
    <mi>l</mi>
  </msub>
  <mrow>
    <mn>Δ</mn>
    <mi>c</mi>
  </mrow>
  <mo lspace="0" rspace="0">|</mo>
  <mo><</mo>
  <mi>ε</mi>
  <mo lspace="0" rspace="0">|</mo>
  <msub>
    <mi>Z</mi>
    <mi>n</mi>
  </msub>
  <mo lspace="0" rspace="0">|</mo>
</math>
<math display="block" style="font-size:1.5rem; padding-bottom:0.5rem">
  <mo lspace="0" rspace="0">|</mo>
  <msub>
    <mi>A</mi>
    <mi>l</mi>
  </msub>
  <msub>
    <mrow>
      <mn>Δ</mn>
      <mi>z</mi>
    </mrow>
    <mi>m</mi>
  </msub>
  <mo lspace="0" rspace="0">|</mo>
  <mo><</mo>
  <mi>ε</mi>
  <mo lspace="0" rspace="0">|</mo>
  <msub>
    <mi>Z</mi>
    <mi>n</mi>
  </msub>
  <mo lspace="0" rspace="0">|</mo>
  <mo>-</mo>
  <mo lspace="0" rspace="0">|</mo>
  <msub>
    <mi>B</mi>
    <mi>l</mi>
  </msub>
  <mo lspace="0" rspace="0">|</mo>
  <mo lspace="0" rspace="0">|</mo>
  <mrow>
    <mn>Δ</mn>
    <mi>c</mi>
  </mrow>
  <mo lspace="0" rspace="0">|</mo>
</math>
<math display="block" style="font-size:1.5rem">
  <mo lspace="0" rspace="0">|</mo>
  <msub>
    <mrow>
      <mn>Δ</mn>
      <mi>z</mi>
    </mrow>
    <mi>m</mi>
  </msub>
  <mo lspace="0" rspace="0">|</mo>
  <mo><</mo>
  <mfrac>
    <mrow>
      <mi>ε</mi>
      <mo lspace="0" rspace="0">|</mo>
      <msub>
        <mi>Z</mi>
        <mi>n</mi>
      </msub>
      <mo lspace="0" rspace="0">|</mo>
      <mo>-</mo>
      <mo lspace="0" rspace="0">|</mo>
      <msub>
        <mi>B</mi>
        <mi>l</mi>
      </msub>
      <mo lspace="0" rspace="0">|</mo>
      <mo lspace="0" rspace="0">|</mo>
      <mrow>
        <mn>Δ</mn>
        <mi>c</mi>
      </mrow>
      <mo lspace="0" rspace="0">|</mo>
    </mrow>
    <mrow>
      <mo lspace="0" rspace="0">|</mo>
        <msub>
          <mi>A</mi>
          <mi>l</mi>
        </msub>
      <mo lspace="0" rspace="0">|</mo>
    </mrow>
</math>

And there we have it!  When iterating with perturbation theory, if the magnitude of <math style="font-size:1.2rem"><mrow><mn>Δ</mn><msub><mi>z</mi><mi>m</mi></msub></mrow></math> is less than that quantity (involving the reference orbit <math style="font-size:1.2rem"><msub><mi>Z</mi><mi>n</mi></msub></math> and coefficients <math style="font-size:1.2rem"><msub><mi>A</mi><mi>l</mi></msub></math> and <math style="font-size:1.2rem"><msub><mi>B</mi><mi>l</mi></msub></math>) we can apply the BLA to skip forward <math style="font-size:1.2rem"><mi>l</mi></math> iterations!

We will compute and save those coefficients and that quantity, calling it our validity radius <math style="font-size:1.2rem"><mi>r</mi></math>, for each number of iterations to skip <math style="font-size:1.2rem"><mi>l</mi></math> beyond each iteration <math style="font-size:1.2rem"><mi>m</mi></math>.

So now we have our coefficients and validity radius <math style="font-size:1.2rem"><mi>r</mi></math> for the 1-iteration BLA:

<math display="block" style="font-size:1.5rem; padding-bottom:0.5rem">
  <msub>
  	<mi>A</mi>
  	<mn>1</mn>
  </msub>
  <mo>=</mo>
  <mn>2</mn>
  <mi>Z</mi>
</math>
<math display="block" style="font-size:1.5rem; padding-bottom:0.5rem">
  <msub>
    <mi>B</mi>
    <mn>1</mn>
  </msub>
  <mo>=</mo>
  <mn>1</mn>
</math>
<math display="block" style="font-size:1.5rem; padding-bottom:0.5rem">
  <mtext><small>that are valid when</small></mtext>
</math>
<math display="block" style="font-size:1.5rem; padding-bottom:0.5rem">
  <mo lspace="0" rspace="0">|</mo>
  <msub>
    <mrow>
      <mn>Δ</mn>
      <mi>z</mi>
    </mrow>
    <mrow>
      <mi>m</mi>
    </mrow>
  </msub>
  <mo lspace="0" rspace="0">|</mo>
  <mo><</mo>
  <msub>
    <mi>r</mi>
    <mn>1</mn>
  </msub>
</math>
<math display="block" style="font-size:1.5rem; padding-bottom:0.5rem">
  <mtext><small>where</small></mtext>
</math>
<math display="block" style="font-size:1.5rem">
  <msub>
    <mi>r</mi>
    <mn>1</mn>
  </msub>
  <mo>=</mo>
  <mfrac>
    <mrow>
      <mi>ε</mi>
      <mo lspace="0" rspace="0">|</mo>
      <msub>
        <mi>Z</mi>
        <mi>m+1</mi>
      </msub>
      <mo lspace="0" rspace="0">|</mo>
      <mo>-</mo>
      <mo lspace="0" rspace="0">|</mo>
      <msub>
        <mi>B</mi>
        <mn>1</mn>
      </msub>
      <mo lspace="0" rspace="0">|</mo>
      <mo lspace="0" rspace="0">|</mo>
      <mrow>
        <mn>Δ</mn>
        <mi>c</mi>
      </mrow>
      <mo lspace="0" rspace="0">|</mo>
    </mrow>
    <mrow>
      <mo lspace="0" rspace="0">|</mo>
        <msub>
          <mi>A</mi>
          <mn>1</mn>
        </msub>
      <mo lspace="0" rspace="0">|</mo>
    </mrow>
</math>

## Merging BLAs

For computing the coefficients for skipping 2 or more iterations, we could use <a target="_blank" href="https://fractalforums.org/index.php?topic=4360.msg31806#msg31806">Zhuoran's math</a> to incrementally compute <math style="font-size:1.2rem"><msub><mi>A</mi><mn>2</mn></msub><mo>,</mo><msub><mi>B</mi><mn>2</mn></msub><mo>,</mo><msub><mi>A</mi><mn>3</mn></msub><mo>,</mo><msub><mi>B</mi><mn>3</mn></msub></math> and so on, and do so from each iteration <math style="font-size:1.2rem"><mi>m</mi></math> of the reference orbit.  But we quickly realize the implications of doing this: that's a lot of coefficients and validity radii to compute, store, and test.

BLA gets a little more conceptually challenging when it comes to managing these coefficients and validity radii in our implementation.  Since we want to potentially skip ahead several iterations, *from each iteration*, we'd naively need to calculate and store those values for each <math style="font-size:1.2rem"><mi>l</mi></math> to skip for each iteration <math style="font-size:1.2rem"><mi>m</mi></math> to skip from.

This, in computer science terms, involves <math style="font-size:1.2rem"><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></math> calculation, storage, and validity-checking if we wanted to be able to skip the maximal number of iterations from all iterations in the reference orbit. "Maximal" meaning that perhaps from iteration <math style="font-size:1.2rem"><mi>m</mi></math> we could try to skip 100 iterations ahead.  But if that validity check fails, we'd want to try to skip ahead 99 iterations.  If that's not possible, we'd try to skip ahead 98 iterations.  And so on.

For this example, a reference orbit of 1,000 iterations would require ~500,000 sets of coefficients and validity radii to be stored, and a worse-case average of 500 validity checks would be required at each iteration.  For a 100,000-iteration reference orbit, ~5,000,000,000 sets of coefficients and validity radii would be stored and 50,000 validity checks could be needed for each iteration.

In other words, we'd consume a lot of memory and compute cycles checking the validity of each BLA to skip 100 iterations, 99 iterations, 98 iterations, etc, from iteration 1.  If all of those validity checks fail, and BLA for iteration 1 doesn't work, we'd do a regular perturbation iteration to get to iteration 2.  Then, for iteration 2, we'd again check BLAs for skipping 100, 99, 98, etc, iterations.  In practice, even though some iterations are skipped, we end up wasting a lot of compute cycles and not improving the overall rendering time compared to regular perturbation.

One solution to this would be to compute BLAs to skip some number of iterations, say 100, for every 100th iteration of the reference orbit.  As long as the BLAs are valid, you could repeatedly skip 100 iterations.  If a BLA is not valid, then you'd compute 100 regular perturbation iterations, then see if the next BLA validates.  I haven't tested this strategy but it seems promising.

Another brilliant solution to this problem was provided by Claude in <a target="_blank" href="https://fractalforums.org/index.php?topic=4360.msg32142#msg32142">this post</a>: we can compute all the 1-iteration BLAs, then "merge" adjacent pairs to create 2-iteration BLAs (without creating "overlapping" merges).  Then merge adjacent 2-iteration BLAs to create 4-iteration BLAs.  And so on, building a binary tree of BLAs.

With this merging strategy, we'd improve to <math style="font-size:1.2rem"><mrow><mi>O</mi><mo>(</mo><mn>2</mn><mi>n</mi><mo>)</mo></mrow></math> complexity.  So we'd compute, store, and check only 2,000 BLAs for a 1,000-iteration reference orbit.  This linear time and space complexity is a vast improvement.  Zhouran offered a suggestion to improve even further upon this in <a target="_blank" href="https://fractalforums.org/index.php?topic=4360.msg34393#msg34393">this post</a>: once we've calculated and used the 1-iteration and 2-iteration BLAs, we can discard them.  Since they provide no real benefit over perturbation theory for 1 or 2 iterations, and they consume most of the memory and validity checking (since there are so many 1- and 2-iteration BLAs), we can improve our time and space complexity to <math style="font-size:1.2rem"><mrow><mi>O</mi><mo>(</mo><mfrac><mi>n</mi><mn>2</mn></mfrac><mo>)</mo></mrow></math> by dropping the lowest 2 BLA levels!  With this merge-and-cull strategy, we need to store only 500 BLAs for a 1,000-iteration reference orbit.

For the merging itself, we refer to <a target="_blank" href="https://fractalforums.org/index.php?topic=4360.msg32142#msg32142">Claude's post</a> again.  Say we are merging two adjacent 1-iteration BLAs at iterations <math style="font-size:1.2rem"><mi>x</mi></math> and <math style="font-size:1.2rem"><mi>y</mi></math>:

<math display="block" style="font-size:1.5rem">
  <mrow>
    <msub>
      <mi>n</mi>
      <mi>x</mi>
    </msub>
    <mo>=</mo>
    <msub>
      <mi>m</mi>
      <mi>x</mi>
    </msub>
    <mo>+</mo>
    <mi>l</mi>
  </mrow>
</math>
<math display="block" style="font-size:1.5rem">
  <mrow>
    <msub>
      <mi>n</mi>
      <mi>y</mi>
    </msub>
    <mo>=</mo>
    <msub>
      <mi>m</mi>
      <mi>y</mi>
    </msub>
    <mo>+</mo>
    <mi>l</mi>
  </mrow>
</math>
<math display="block" style="font-size:1.5rem">
  <mrow>
    <mtext><small>where</small></mtext>
  </mrow>
</math>
<math display="block" style="font-size:1.5rem">
  <mrow>
    <mi>l</mi>
    <mo>=</mo>
    <mn>1</mn>
  </mrow>
</math>

Since the BLAs at iterations <math style="font-size:1.2rem"><mi>x</mi></math> and <math style="font-size:1.2rem"><mi>y</mi></math> are adjacent, when merged we'd have:

<math display="block" style="font-size:1.5rem">
  <mrow>
    <msub>
      <mi>n</mi>
      <mi>y</mi>
    </msub>
    <mo>=</mo>
    <msub>
      <mi>m</mi>
      <mi>x</mi>
    </msub>
    <mo>+</mo>
    <mi>l</mi>
  </mrow>
</math>
<math display="block" style="font-size:1.5rem">
  <mrow>
    <mtext><small>where</small></mtext>
  </mrow>
</math>
<math display="block" style="font-size:1.5rem">
  <mrow>
    <mi>l</mi>
    <mo>=</mo>
    <mn>2</mn>
  </mrow>
</math>

In other words, we create a single new BLA that skips 2 iterations beyond iteration <math style="font-size:1.2rem"><mi>x</mi></math>.  So now we have two separate BLAs for iteration <math style="font-size:1.2rem"><mi>x</mi></math>, both with their own coefficients and validity radius.  One BLA advances 1 iteration, and the new one advances 2 iterations.  Depending on the pixel being calculated, one, none, or both BLAs may be valid.  Obviously we'd want to apply the 2-iteration BLA if both are valid.

To find the merged coefficients and validity radius <math style="font-size:1.2rem"><mi>r</mi></math>, we'll call the BLAs we are merging <math style="font-size:1.2rem"><mi>x</mi></math> and <math style="font-size:1.2rem"><mi>y</mi></math>.  Then, using Claude's formulas for merging BLAs:

<math display="block" style="font-size:1.5rem; padding-bottom:0.5rem">
  <mrow>
    <mi>A</mi>
    <mo>=</mo>
    <msub>
      <mi>A</mi>
      <mi>x</mi>
    </msub>
    <mo>&sdot;</mo>
    <msub>
      <mi>A</mi>
      <mi>y</mi>
    </msub>
  </mrow>
</math>
<math display="block" style="font-size:1.5rem; padding-bottom:0.5rem">
  <mrow>
    <mi>B</mi>
    <mo>=</mo>
    <msub>
      <mi>A</mi>
      <mi>x</mi>
    </msub>
    <mo>&sdot;</mo>
    <msub>
      <mi>B</mi>
      <mi>x</mi>
    </msub>
    <mo>+</mo>
    <msub>
      <mi>B</mi>
      <mi>y</mi>
    </msub>
  </mrow>
</math>
<math display="block" style="font-size:1.5rem; padding-bottom:0.5rem">
  <mrow>
    <msub>
      <mi>r</mi>
    </msub>
    <mo>=</mo>
    <mtext>min</mtext>
    <mo>(</mo>
    <msub>
      <mi>r</mi>
      <mi>x</mi>
    </msub>
    <mo>,</mo>
    <mtext>max</mtext>
    <mo>(</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mfrac>
      <mrow>
        <msub>
          <mi>r</mi>
          <mi>y</mi>
        </msub>
        <mo>-</mo>
        <mo lspace="0" rspace="0">|</mo>
        <mi>B</mi>
        <mo lspace="0" rspace="0">|</mo>
        <mo lspace="0" rspace="0">|</mo>
        <mi>c</mi>
        <mo lspace="0" rspace="0">|</mo>
      </mrow>
      <mrow>
      	<mo lspace="0" rspace="0">|</mo>
        <mi>A</mi>
      	<mo lspace="0" rspace="0">|</mo>
      </mrow>
    </mfrac>
    <mo>)</mo>
    <mo>)</mo>
  </mrow>
</math>

We can perform this merging step on each "level" of BLAs, creating 2-iteration BLAs from the 1-iteration ones, then creating 4-iteration BLAs from the 2-iteration ones, and so on, until we run out of BLAs to merge.  At the end of this process, we'll have the single largest BLA, at the highest "level", for the first BLA iteration:

<p class="wrap-wider-child"><img class="center-block width-100" src="${SITE_ROOT_REL}/s/img/2023/BLA-diagram.png"/></p>

In the diagram above, each circle represents a Mandelbrot set iteration.  The gray arrows represent regular perturbation theory iterations to move sequentially from one iteration to the next.  The orange dotted arrows represent iterations that can be skipped by applying a BLA.  For the "Level 1" BLAs, we "skip" only a single iteration.  Adjacent pairs of "Level 1" BLAs are merged to create 2-iteration "Level 2" BLAs.  We merge all the way to the largest BLA, at "Level 4" which can skip 8 iterations.

## BLA Validity Checking

For each iteration we run, we have to efficiently test BLAs to find the largest valid one, or, if no valid BLAs are found, advance to the next iteration by running a regular perturbation theory iteration.

I tested a few algorithms for finding the best valid BLA at an iteration, and ended up using a simple linear search:

1. Test the lowest-level BLA
  * If valid, proceed
  * If not valid, end here: no BLAs at this iteration are valid
1. Test the highest-level BLA
  * If valid, stop: we have found the best BLA at this iteration
  * If not valid, repeat this step with the next-highest level BLA

Since the validity radius gets progressively smaller as we move from lower-level BLAs to higher-level BLAs, we know we can stop checking immediately if the lowest-level BLA is not valid.  Then, since we want to apply the largest possible BLA, we can simply test the rest in descending order.

For example, in the diagram above:

At iteration 1, there are no BLAs, so apply a perturbation theory iteration to move to iteration 2.

At iteration 2, we first test the "Level 1" BLA.  If valid, we then test the "Level 4" BLA.  Say that's valid, and we can apply that BLA to end up at iteration 10.

Then at iteration 10, we continue this algorithm.

*Note that as mentioned above, with the "merge and cull" strategy the BLAs at levels 1 and 2 are dropped in the actual implementation: it's not worth doing the BLA validity checking to advance only 1 or 2 iterations.*

## Epsilon

The key to the whole concept of BLA is the <math style="font-size:1.2rem"><mi>ε</mi></math> (epsilon) value.  Recall that when the squared term in the perturbation equation value is "small enough" to be negligible we can apply the linear approximation to skip many iterations, where "small enough" means less than the non-squared term by some factor <math style="font-size:1.2rem"><mi>ε</mi></math>:

<math display="block" style="font-size:1.5rem; padding-bottom:0.5rem">
  <mo lspace="0" rspace="0">|</mo>
  <msubsup>
    <mrow>
      <mn>Δ</mn>
      <mi>z</mi>
    </mrow>
    <mi>n</mi>
    <mn>2</mn>
  </msubsup>
  <mo lspace="0" rspace="0">|</mo>
  <mo><</mo>
  <mi>ε</mi>
  <mo lspace="0" rspace="0">|</mo>
  <mn>2</mn>
  <msub>
    <mi>Z</mi>
    <mi>n</mi>
  </msub>
  <msub>
    <mrow>
      <mn>Δ</mn>
      <mi>z</mi>
    </mrow>
    <mi>n</mi>
  </msub>
  <mo lspace="0" rspace="0">|</mo>
</math>

In the fractalforums.org discussion on this, this <math style="font-size:1.2rem"><mi>ε</mi></math> value is directly based on the implementation to the underlying number values being used for the calculations.  In <a target="_blank" href="https://fractalforums.org/index.php?topic=4360.msg31806#msg31806">this post</a>, Zhuoran gives values of <math style="font-size:1.2rem"><mrow><mi>ε</mi><mo>=</mo><mn>2</mn><mo>&times;</mo><msup><mn>10</mn><mn>-24</mn></msup></mrow></math> for single-precision floating-point values, and <math style="font-size:1.2rem"><mrow><mi>ε</mi><mo>=</mo><mn>2</mn><mo>&times;</mo><msup><mn>10</mn><mn>-53</mn></msup></mrow></math> for double-precision.

I found those  values to be fine in some of my initial testing, but noticed severe distortion or even totally wrong results being rendered in other cases.  In general, it looks like smaller <math style="font-size:1.2rem"><mi>ε</mi></math> values must be used when "zooming" into a deeper locations, even when the math/number implementation doesn't change.

## Auto-Epsilon

In my experimentation I found that for most locations, when the <math style="font-size:1.2rem"><mi>ε</mi></math> value is made a little smaller than it needs to be, the rendered images look accurate but fewer iterations are skipped with BLA (and thus take longer to render).  Or, if the <math style="font-size:1.2rem"><mi>ε</mi></math> is made a little larger than optimal, the image can often look mostly the same (slightly inaccurate) and is rendered faster.  Make it too large, however, and strange totally inaccurate results are rendered.

Using the above, I realized we can algorithmically find a good <math style="font-size:1.2rem"><mi>ε</mi></math> for any location:

1. Use regular perturbation theory to calculate the "true" iterations count value for a series of test points
1. Starting with some <math style="font-size:1.2rem"><mi>ε</mi></math> value, compute BLAs and compare the BLA-accelerated iterations result with the "true" perturbation result
1. If any point has a perturbation/BLA difference exceeding some threshold (I use 0.001%) then the <math style="font-size:1.2rem"><mi>ε</mi></math> is considered "wrong" and a smaller (more accurate, slower) <math style="font-size:1.2rem"><mi>ε</mi></math> value is needed
1. If all test points are correct, then compare the average number of iterations skipped vs the previous "best" <math style="font-size:1.2rem"><mi>ε</mi></math> value.  If more iterations are skipped, then try a larger (less accurate, faster) value for <math style="font-size:1.2rem"><mi>ε</mi></math>.

I implemented the above idea using a binary search, where the <math style="font-size:1.2rem"><mi>ε</mi></math> exponent is doubled or halved to find lower/upper bounds, and then the midpoint exponent is tested to repeatedly approach the "good" value.  Since BLAs are relatively fast to calculate for each new <math style="font-size:1.2rem"><mi>ε</mi></math> value tested, we can quickly arrive at a <math style="font-size:1.2rem"><mi>ε</mi></math> value that produces fast, accurate results for the points tested.

## Manual Epsilon

If a good <math style="font-size:1.2rem"><mi>ε</mi></math> is known for a particular location, or for testing a specific <math style="font-size:1.2rem"><mi>ε</mi></math> value, Very Plotter's "algorithm" parameter string can specify the value to be used (instead of using the "auto <math style="font-size:1.2rem"><mi>ε</mi></math>" algorithm described above).

The algorithm string can be set in the "algorithm options" pane of the controls menu, or in the URL bar.

For example, to use <math style="font-size:1.2rem"><mrow><mi>ε</mi><mo>=</mo><mn>1</mn><mo>&times;</mo><msup><mn>10</mn><mn>-114</mn></msup></mrow></math> at a scale that requires `floatexp` math, the algorithm can be specified as `bla-floatexp-blaepsilon1.0eminus114`.

To use <math style="font-size:1.2rem"><mrow><mi>ε</mi><mo>=</mo><mn>1.5</mn><mo>&times;</mo><msup><mn>10</mn><mn>-26</mn></msup></mrow></math> at a scale that requires `float` math, the algorithm can be specified as `bla-float-blaepsilon1.5eminus26`.

Again, for all locations, the above auto-discovered <math style="font-size:1.2rem"><mi>ε</mi></math> value should work well, and BLA can be used by specifying the `bla-auto` algorithm.

## Speed Comparison

To get a sense for BLA's performance, I've rendered a number of locations with both BLA and the previous fastest SA algorithm (perturbation theory with series approximation).  Even with the additional initial computation steps (locating a minibrot nucleus, and calculating several sets of BLAs to find the best <math style="font-size:1.2rem"><mi>ε</mi></math>) BLA is often much faster than SA.

All times below are for my M1 Mac, with 7 worker threads, rendering a relatively small 828x587 resolution window.  I used a small window to speed up the test renders, but since BLA relies so much on the initial computation that occurs before any pixels are calculated, BLA should be even faster relative to SA for renders with many more pixels.

The images below are links that can be clicked to open the associated locations in Very Plotter.  Some of the deeper locations take an extremely long time to render.  Those slow locations are linked below more for future reference and performance measurement.

### Example Location 1

<p class="wrap-wider-child"><a target="_blank" href="${SITE_ROOT_REL}/very-plotter/?plot=Mandelbrot-set&v=5&n=350000&mag=2.89656976744e89&centerX=-7.436439270580283166312913614158260087397027582242801496395455597668233520653387568335095347389089128439115293880033690335629808e-1&centerY=1.318259808779069471464240119400251641519240233341288858358434339980559877894601271811785368484350810069803960858084841450929593e-1&gradient=bBgwo-B.141414-mod2222-shift2&bgColor=b&smooth=on-show&algo=bla-auto"><img class="center-block width-100" src="${SITE_ROOT_REL}/s/img/2023/BLA-example-1.jpg"/></a></p>

This location is a deeper continuation from the "1" preset in Very Plotter.  BLA shows an impressive speed improvement:

* **99s** with BLA (about 1.5 minutes, with `bla-float` algorithm)
* **1009s** (10.2x as long as BLA!) using perturb. theory with series approximation (with `perturb-sapx6-float`) 

### Example Location 2

<p class="wrap-wider-child"><a target="_blank" href="${SITE_ROOT_REL}/very-plotter/?plot=Mandelbrot-set&v=5&n=2000000&mag=4.98981260647e152&centerX=-1.928532931364664508128629733239928208230411296677913777145287257081343315454333732943347528524641352140515347513234388519354223613116741857456447761021147175799733212653e0&centerY=2.77503784777739169751349389798092402078848330425867002811249042300236773322474371120872969797094461837014892211874313304811106592251611950572483773205238048198116e-25&gradient=GBswGBswGBsw-G.024269-s.d9794f-mod8000&bgColor=b&smooth=on-show&slopeLightDir=bl&slopeDepth=3&algo=bla-auto"><img class="center-block width-100" src="${SITE_ROOT_REL}/s/img/2023/BLA-example-2.jpg"/></a></p>

This location is a deeper continuation from my "Cerebral Spin" location.  It renders much more quickly with BLA:

* **358s** with BLA (about 6 minutes, with `bla-float` algorithm)
* **12,958s** (about 3.6 hours, 36.2x as long as BLA!!) using perturb. theory with series approximation (with `perturb-sapx7-float`)

### Example Location 3

<p class="wrap-wider-child"><a target="_blank" href="${SITE_ROOT_REL}/very-plotter/?plot=Mandelbrot-set&v=5&n=350000&mag=9.5e693&centerX=-1.76910833040747728089230624355777848356006391186234006507787883404189297159859080844234601990886820204375798539711744042815186207867460953613415842432757944592767829349335811233344529101414256593211862449597012320484442182435300186806636928772790198745922046142684209058217860629186666350353426119156588068800663472823306396040025965062872111452567447461778249159612483961826938045120616222919425540724435314735525341255820663672868054494834304368733487681716181154843412847462148699796875704432080579735378707932099259943340496912407317825152866860761144612772496664270830079426435441269883492784901017790042850890739485773306607264972085711338137708893699076457669580514290256722060097263508020311445e0&centerY=9.020688057072617600360935984947620112305584674123866889727919817129110000273070325734652748577260411641977284267953435586679185748062521452185618401720512375928279282840017325461435395900347333831678867372709608373937732035861376732233573306124188011779554347246727032292516900609906698962747844988602428404977018518490333180457529450252363392753154488987278181741626980443558895836087364851272299469096298326327508396224591600469344439018862266215051078424481599350178419410453543640423233428241935033928198320388056103242790716490107710772320243918427564538670525393149453336876275177112446102725568808188538445639872408945280914915450181814987968593191561336143542710532436529573416414086480117573e-3&gradient=bBdwbBgwbBdw-g.d9af70-b.29305a-d.1c213f-mod700-offset687&bgColor=b&smooth=on-show&slopeLightDir=tl&slopeDepth=4&algo=bla-auto"><img class="center-block width-100" src="${SITE_ROOT_REL}/s/img/2023/BLA-example-3.jpg"/></a></p>

This is a location by <a target="_blank" href="https://www.deviantart.com/dinkydauset/art/SSSSSSSSSSSSSSSS-384940293">Dinkydau, called "SSSSSSSSSSSSSSSS"</a>.  This is where I first saw how the <math style="font-size:1.2rem"><mi>ε</mi></math> value may be dramatically different from one location to another.  This location takes a long time to do the initial nucleus-finding and reference orbit steps, so I don't recommend actually viewing it with BLA!  The SA render was somewhat faster than BLA, at least for the small test window.  For a larger window, I hoped BLA would be faster.

* **3,438s** with BLA (about 57 minutes, with `bla-floatexp`) 
* **2,076s** (about 35 minutes, 0.6x as long as BLA) using perturb. theory with series approximation (with `perturb-sapx8-floatexp`)

This is an interesting location because BLA appears to be slower, or not much faster, than SA.  If and when I am able to make improvements to BLA, I'll be able to re-visit this location again to see if BLA gains any performance relative to SA.

I was hoping that, per pixel, BLA is slightly faster than SA here.  If so, the initial nucleus-finding time would mean that only large renders would be faster with BLA.  This was a mostly unnecessary tangent to follow, but I wanted to see if BLA appeared to be actually faster than SA, and, if so, whether I could predict the number of megapixels beyond which a BLA render would be faster overall than an SA render.  I usually do 23-megapixel renders for gallery images (which I then downsample for a cleaner-looking 5.76-megapixel final image), so I'm also curious to see if BLA would be faster for a render of that size.

To test this, I guessed that I should be able to plot the time-vs-megapixels data as a best-fit line for both BLA and SA and see where the lines cross.  Beyond that many pixels, BLA should be faster.  To make a more accurate trend line, I ran renders for both BLA and SA.  Since the <math style="font-size:1.2rem"><mi>ε</mi></math> for BLA can change depending on the render size and aspect ratio, I ran the following renders all at a 16:9 aspect ratio.

<style>
	table {
		border-collapse: collapse;
		margin-left: auto;
		margin-right: auto;
	}
	td {
		border-top: 1px solid #999;
		text-align: center;
		padding: 0.2rem 0.5rem 0.2rem 0.5rem;
	}
	th {
		text-align: center;
	}
</style>

<table>
<tr><th>window</th><th>megapixels</th><th>BLA</th><th>SA</th><th>SA/BLA ratio</th></tr>
<tr><td>641x356</td><td>0.228</td><td>1,438s</td><td>1,045</td><td>0.727</td></tr>
<tr><td>928x522</td><td>0.486</td><td>2,608s</td><td>2,066s</td><td>0.792</td></tr>
<tr><td>1250x703</td><td>0.879</td><td>4,444s</td><td>3,595</td><td>0.809</td></tr>
<tr><td>1600x900</td><td>1.440</td><td>7,068s</td><td>5,805s</td><td>0.821</td></tr>
<tr><td>2311x1300</td><td>3.004</td><td>14,092s</td><td>11,917s</td><td>0.846</td></tr>
</table>

The auto-epsilon testing algorithm uses more test points for larger renders, so BLA's initial <math style="font-size:1.2rem"><mi>ε</mi></math>-finding time also increases linearly with render size, but it shouldn't add much time overall.  I was surprised to see that, even with the variable number of test points, the <math style="font-size:1.2rem"><mi>ε</mi></math> used was always <math style="font-size:1.2rem"><mrow><mi>ε</mi><mo>=</mo><mn>1</mn><mo>&times;</mo><msup><mn>10</mn><mn>-122</mn></msup></mrow></math>.

Plugging the BLA data <a target="_blank" href="https://www.wolframalpha.com/input?i=fit+linear+%7B%280.228%2C1438%29%2C%280.486%2C2608%29%2C%280.879%2C4444%29%2C%281.44%2C7068%29%2C%283.004%2C14092%29%7D">into WolframAlpha</a> gives a best fit line of:

<!-- BLA: fit linear {(0.228,1438),(0.486,2608),(0.879,4444),(1.44,7068),(3.004,14092)} -->
<!-- 4561.69x + 422.22 -->

<math display="block" style="font-size:1.5rem; padding-bottom:0.5rem">
  <mrow>
    <msub>
      <mi>y</mi>
      <mtext>seconds:BLA</mtext>
    </msub>
    <mo>=</mo>
    <mn>4561.69</mn>
    <msub>
      <mi>x</mi>
      <mtext>megapixels</mtext>
    </msub>
    <mo>+</mo>
    <mn>422.22</mn>
  </mrow>
</math>

Which I interpret as 422 seconds (initial compute time for nucleus-finding, reference orbit, and BLA computation), plus 4561 seconds per megapixel.

<!-- SA: fit linear {(0.228,1045),(0.486,2066),(0.879,3595),(1.44,5805),(3.004,11917)} -->
<!-- 3915.47x + 158.062 -->

And the SA data <a target="_blank" href="https://www.wolframalpha.com/input?i=fit+linear+%7B%280.228%2C1045%29%2C%280.486%2C2066%29%2C%280.879%2C3595%29%2C%281.44%2C5805%29%2C%283.004%2C11917%29%7D">best-fit line of</a>:

<math display="block" style="font-size:1.5rem; padding-bottom:0.5rem">
  <mrow>
    <msub>
      <mi>y</mi>
      <mtext>seconds:SA</mtext>
    </msub>
    <mo>=</mo>
    <mn>3915.47</mn>
    <msub>
      <mi>x</mi>
      <mtext>megapixels</mtext>
    </msub>
    <mo>+</mo>
    <mn>158.062</mn>
  </mrow>
</math>

Which I interpret as 158 seconds (initial compute time for reference orbit and SA coefficients), plus 3915 seconds per megapixel.

Since the BLA equation starts with a higher initial compute time, and requires more seconds per megapixel, it will always be slower, at this location, than SA.  I'll definitely re-visit this location in the future since it's a good benchmark for BLA vs. SA performance.

<!-- WolframAlpha accepts "solve system of 2 equations" input, where both equations can be entered-->

For this location I've also created an animation showing the effect of changing the value of <math style="font-size:1.2rem"><mi>ε</mi></math>:

<p class="wrap-wider-child"><img class="center-block width-100" src="${SITE_ROOT_REL}/s/img/2023/BLA-example-3-animation.gif"/></p>

### Example Location 4

<p class="wrap-wider-child"><a target="_blank" href="${SITE_ROOT_REL}/very-plotter/?plot=Mandelbrot-set&v=5&n=8500000&mag=1.02214650766e1744&centerX=-1.94154386426666073385494419139602817911002190783983806486255995390970564901841266654110342825040027833437400890080285153552529327388232371146283717027668881590861362991408508818382192753637902940013651676928079154959840543639128710705789946261966322401536496779684342233569702585514036404569468368027709623003705407121586854803770468577214029441021980626839467735283281182663319948425162501139757726233019859661104651575768057772089890530536093546336903563326842789114624929967044053119714067132315872304777456576801951933320843131435868568417931243209070672982581424895069161511755346174216235385885774648591314732196413689311503556588612727187269408874241691974841087855881441722561548154608791302804221857246655758140119158227702095944162158523180675710335847354760536529095575520493785351579199840120211532761876756343130808435230665830020934938543221112081079909739139542994199217699113323641765080079007385893739678573743535741773511560401049413603608150466977026779033151892911965595117342808620118692133269782138546471855839497910778747195417038495889140353552407452462813979865884247117219964609626521955405883942216120822382390240301518825634451113002797903958517780042374768669868605876961997371941004054340838582253877498107382335786449824606444004049030482264919457882439320013661467456591605894357554801802587618779544348760296765593619667730003550914436687920459780348984199661509102043839301448365028378964509455099138460773025273107651621339672997109207592844405085921355044477761954888096227770110133580290394997631024115310189617576320280301943133838300075519310361941099131596321800889020233797326469236132725205057764663720710328551666848930753609443359331448130481041900710459691431714913426703252751947571967544670147394307762368018437507996150024757785995051757400629127935386e0&centerY=8.92293339542148802272919829589858035157573184985491365534013497345807545516142511469397149227340254773284727735761562371422707868600251597663489406963042316241464024727277383914467526119307103666479936023211178563973072348476624466716957624802981233723506239398422794680891860496058103906488118267738131742630907369904328623619542954811212850982953513536315164703408712552692095279609420680275306429101648926406275381107379180907707352263859347328016787764472509420142628506266103582236137609984767003142310239389456832848062120259156957805594956209430304776643728042483525019600600524987444945171539843757282351045893033312998396154950430039383326640463532644580094068611392337878766755748669395133717213659853675344530279894193194970966181411023333634050346491682169078160619901053509115040890613086868771310251761807249318903963806396677209237220915874371487343505175925749276986089526041420475965999730124291818837015269557404911672743115914752807530580744001871407992010328708110165611600502841642819890286618657551516238241984988123010201511719788299877887464701980936133340884217631999170602503865525907133147554401909151134753881604517170419895018205554070493063143570519191651341914131478022040900027393959614371774452159183649357373611813933649181034898584048409764177590626963963739334568374899911953794270807407737420757720424281568070343108466249711669614733043869539689948379942106459090499557342715575511429200094759829317273504456001382020853064149767176560041825645958181314452312930161303545310845428551923614318965269773077821275030276642958427531272828515379072486562852557909567639681274345070907241110253800158209455298867022577798925055205722291510540395033930802226561727219875181190640009570845824522532447566320440377845742731390068739472139795727332157605065081990993127837e-5&gradient=bBgwo-B.141414-mod200-shift2&bgColor=b&smooth=on-show&algo=bla-auto"><img class="center-block width-100" src="${SITE_ROOT_REL}/s/img/2023/BLA-example-4.jpg"/></a></p>

This location is <a target="_blank" href="https://www.deviantart.com/microfractal/art/Mandelbrot-Deep-Julia-Morphing-31-895133397">"Mandelbrot Deep Julia Morphing 31" by Microfractal on deviantart.com</a>.  This location takes an *extremely* long time to do the initial nucleus-finding and reference orbit steps, so again here I don't recommend actually viewing it in Very Plotter!

This location took such a long time to render (multiple days, where I often reduced the worker count down to 1 or 2 workers so I could continue to use the computer) that I don't have an SA performance comparison for it.  This was a useful, very deep, location for testing BLA and the auto-epsilon algorithm.

A larger render of this location is available on the <a href="${SITE_ROOT_REL}/mandelbrot-gallery/2023.html">2023 Mandelbrot set gallery page</a>.

### Example Location 5

<p class="wrap-wider-child"><a target="_blank" href="${SITE_ROOT_REL}/very-plotter/?plot=Mandelbrot-set&v=5&n=50100&mag=1.8e157&centerX=-1.99996619445037030418434688506350579675531241540724851511761922944801584242342684381376129778868913812287046406560949864353810575744772166485672496092803920095332176654843899e0&centerY=3.00138243679093832407249730397759249873468311907733352701742572801204749756148235811856472992884140755192241865049781816254785289455481571221457726813208724311827020946640834e-34&gradient=Bwrw-B.282828-r.BE1428-mod760-offset190&bgColor=b&smooth=on-show&slopeLightDir=tr&slopeDepth=6&algo=bla-auto"><img class="center-block width-100" src="${SITE_ROOT_REL}/s/img/2023/BLA-example-5.jpg"/></a></p>

This is the <a target="_blank" href="https://www.deviantart.com/dinkydauset/art/Flake-372739781">"Flake" location, by Dinkydau</a>.  A larger render of this location is available on the <a href="${SITE_ROOT_REL}/mandelbrot-gallery/2022.html">2022 Mandelbrot set gallery page</a>.

* **58s** with BLA (`bla-float` algorithm) 
* **89s** (1.5x as long as BLA!) with perturb. theory with series approximation (`perturb-sapx9.2-float`)

For a larger 1600x900 window, with 6 workers:

* **220s** with BLA (about 3.5 minutes, with `bla-float`)
* **536s** (about 9 minutes, 2.4x as long as BLA!) with perturb. theory with series approximation (`perturb-sapx9.2-float`)

### Example Location 6

<p class="wrap-wider-child"><a target="_blank" href="${SITE_ROOT_REL}/very-plotter/?plot=Mandelbrot-set&v=5&n=1200000&mag=5.62180579216e227&centerX=-7.49624497378761682078626204268361386845295278123640257544815714245582864796728016987502039767791356081486877471965951748581253882975777885730827532104698067397213779012974511726247624509405298147130483778736122972203130169470392875899999999e-1&centerY=3.42701087404601694517295154574947486805153467243911185317485473837059577293593017184299977871322279421545343662899820059191420820763267478078097849678484380769051040182930130906954219841357439242588516636723119208741633849706549538649999999e-2&gradient=Bbwgb-b.284b75-g.28755f-mod14500&bgColor=b&smooth=off-hide&algo=bla-auto"><img class="center-block width-100" src="${SITE_ROOT_REL}/s/img/2023/BLA-example-6.jpg"/></a></p>

This is the <a target="_blank" href="https://www.deviantart.com/dinkydauset/art/Evolution-of-trees-402876071">"Evolution of Trees" location, by Dinkydau</a>.

* **3882s** with BLA (about 64 minutes, with `bla-float`, skipping on average 989,000 iterations per pixel)
* **6553s** (1.7x as long as BLA!) with perturb. theory with series approximation (`perturb-sapx9-float`, skipping 1,063,940 iterations per pixel)

## Closing Thoughts

Implementing BLA was a serious challenge for me.  It took several tries, but now Very Plotter is at the point where it's working well enough for the <a target="_blank" href="https://github.com/philthompson/visualize-primes/releases/tag/v0.10.0">v0.10.0 release</a>.  This was a big undertaking, not just for BLA but for this 1100-line blog post as well!

It was very rewarding to read through the fractalforums.org discussion on BLA (<a target="_blank" href="https://fractalforums.org/index.php?topic=4360.30">starting at the top of page 3 here</a>) and get it working myself.  I owe a lot to those forum contributors for their general spirit of openness and for sharing their hard-earned knowledge on these topics.

It's worth mentioning that BLA is not yet compatible with stripe average coloring, which was <a href="">recently added to Very Plotter</a>.  This doesn't seem to matter too much because BLA works at very deep locations where stripe average coloring (at least as I've implemented it so far) isn't worth using.

I'd like to experiment with other strategies for efficiently computing, storing, and testing BLAs.  I feel like even more performance gains are possible with a bit more tinkering.  I'd also like to look into WebAssembly for handling some of the arbitrary-precision and floatexp math in Very Plotter, which might dramatically improve Very Plotter's BLA performance.

But those are tasks for another day.

## Further Reading

If you know of any other resources describing the use of BLA for Mandelbrot set rendering, let me know!

* [fractalforums.org discussion on BLA](https://fractalforums.org/index.php?topic=4360.30)
* [Claude Heiland-Allen's "Deep Zoom" page](https://mathr.co.uk/web/deep-zoom.html)

