if(typeof importScripts==="function"){let scriptAppVersion=null;if(!appVersion){scriptAppVersion=function(){let urlParams=new URLSearchParams(self.location.search);return urlParams.has("v")?urlParams.get("v"):"unk"}()}importScripts("infnum.js?v="+(appVersion||scriptAppVersion));importScripts("floatexp.js?v="+(appVersion||scriptAppVersion))}function getBLAEpsilonFromAlgorithm(algorithm){if(!algorithm.includes("blaepsilon")){return null}if(algorithm.includes("blaepsilonauto")){return null}try{return createInfNumFromExpStr(algorithm.split("-").find((e=>e.startsWith("blaepsilon"))).substring(10).replaceAll("minus","-"))}catch(e){console.log("ERROR CAUGHT when parsing custom blaepsilon from algorithm name ["+algorithm+"]:");console.log(e.name+": "+e.message+":\n"+e.stack.split("\n").slice(0,5).join("\n"));return null}}function searchForBestBLA(sortedArray,deltaZAbs,math){let hi=sortedArray.length-1;let lowestValid=null;if(hi>0){if(math.lt(deltaZAbs,sortedArray[hi].r2)){lowestValid=hi;hi--}else{return{bestValidBLA:false}}}for(let x=0;x<=hi;x++){if(math.lt(deltaZAbs,sortedArray[x].r2)){lowestValid=x;break}}return{bestValidBLA:lowestValid===null?false:sortedArray[lowestValid]}}const windowCalcBackgroundColor=-1;const windowCalcIgnorePointColor=-2;const plots=[{name:"Mandelbrot-set",pageTitle:"Mandelbrot set",calcFrom:"window",desc:"The Mandelbrot set is the set of complex numbers, that when repeatedly plugged into the following "+"simple function, does <i>not</i> run away to infinity.  The function is z<sub>n+1</sub> = z<sub>n</sub><sup>2</sup> + c.<br/>"+"For each plotted point <code>c</code>, we repeat the above function many times.<br/>"+"If the value jumps off toward infinity after say 10 iterations, we display a color at the pixel for point <code>c</code>.<br/>"+"If the value doesn't go off toward infinity until say 50 iterations, we pick a quite different color for that point.<br/>"+"If, after our alloted number of iterations has been computed, the value still hasn't gone off to infinity, we color that pixel the backgrond color (defaulting to black)."+"<br/><br/>Wikipedia has a terrific <a target='_blank' href='https://en.wikipedia.org/wiki/Mandelbrot_set'>article with pictures</a>."+"<br/><br/>My favorite explanation I've found so far is <a target='_blank' href='https://www.youtube.com/watch?v=FFftmWSzgmk'>this Numberphile video on YouTube</a>."+"<br/><br/><b>Tips for using this Mandelbrot set viewer</b>:"+"<br/>- When not zoomed in very far, keep the <code>n</code> (iterations) parameter low for faster calculation (use N and M keys to decrease/increase the <code>n</code> value)."+"<br/>- To see more detail when zoomed in, increase the <code>n</code> (iterations) parameter with the M key.  Calculations will be slower."+"<br/>- <a target='_blank' href='https://philthompson.me/very-plotter-tips.html'>More tips</a>",gradientType:"mod",computeBoundPointColor:function(n,precis,algorithm,x,y,useSmooth){const maxIter=n;if(algorithm.includes("basic")&&algorithm.includes("float")&&!algorithm.includes("floatexp")){const bailoutSquared=useSmooth?32*32:4;let ix=0;let iy=0;let ixSq=0;let iySq=0;let ixTemp=0;let iter=0;while(iter<maxIter){ixSq=ix*ix;iySq=iy*iy;if(ixSq+iySq>bailoutSquared){break}ixTemp=x+(ixSq-iySq);iy=y+2*ix*iy;ix=ixTemp;iter++}if(iter>=maxIter){return windowCalcBackgroundColor}else{if(useSmooth){let fracIter=Math.log(ixSq+iySq)/2;fracIter=Math.log(fracIter/Math.LN2)/Math.LN2;iter+=1-fracIter}return iter}}const math=selectMathInterfaceFromAlgorithm(algorithm);const bailoutSquared=useSmooth?math.createFromNumber(32*32):math.four;const xConv=typeof x.v=="bigint"?math.createFromInfNum(x):math.createFromExpString(floatExpToString(x));const yConv=typeof y.v=="bigint"?math.createFromInfNum(y):math.createFromExpString(floatExpToString(y));var ix=structuredClone(math.zero);var iy=structuredClone(math.zero);var ixSq=structuredClone(math.zero);var iySq=structuredClone(math.zero);var ixTemp=structuredClone(math.zero);var iter=0;try{while(iter<maxIter){ixSq=math.mul(ix,ix);iySq=math.mul(iy,iy);if(math.gt(math.add(ixSq,iySq),bailoutSquared)){break}ixTemp=math.add(xConv,math.sub(ixSq,iySq));iy=math.add(yConv,math.mul(math.two,math.mul(ix,iy)));ix=ixTemp;ix=math.truncateToSigDig(ix,precis);iy=math.truncateToSigDig(iy,precis);iter++}if(iter==maxIter){return windowCalcBackgroundColor}else{if(useSmooth){let fracIter=math.log(math.add(ixSq,iySq))/2;fracIter=Math.log(fracIter/Math.LN2)/Math.LN2;iter+=1-fracIter}return iter}}catch(e){console.log("ERROR CAUGHT when processing point (x, y, iter, maxIter): ["+math.toExpString(x)+", "+math.toExpString(y)+", "+iter+", "+maxIter+"]:");console.log(e.name+": "+e.message+":\n"+e.stack.split("\n").slice(0,5).join("\n"));return windowCalcIgnorePointColor}},computeBoundPointColorStripes:function(n,precis,algorithm,x,y,useSmooth){let stripeDensity=6;const stripeSkipFirstIters=0;const maxIter=n;const mixFactor=1e5;let userStripeDensity;try{userStripeDensity=parseFloat(algorithm.split("-").find((e=>e.startsWith("stripedensity"))).substring(13))}catch(e){}if(userStripeDensity!==undefined&&userStripeDensity>=.1&&userStripeDensity<=100){stripeDensity=userStripeDensity}const bailoutSquared=useSmooth?64*64:4;const logBailoutSquared=Math.log(bailoutSquared);let ix=0;let iy=0;let ixSq=0;let iySq=0;let ixTemp=0;let iter=0;let avgCount=0;let avg=0;let lastAdded=0;let lastZ2=0;while(iter<maxIter){ixSq=ix*ix;iySq=iy*iy;if(iter>stripeSkipFirstIters){avgCount++;lastAdded=.5*Math.sin(stripeDensity*Math.atan(iy/ix))+.5;avg+=lastAdded}lastZ2=ixSq+iySq;if(lastZ2>bailoutSquared){break}ixTemp=x+(ixSq-iySq);iy=y+2*ix*iy;ix=ixTemp;iter++}if(iter>=maxIter){return windowCalcBackgroundColor}else{if(!useSmooth){return avg/avgCount}let prevAvg=(avg-lastAdded)/(avgCount-1);avg=avg/avgCount;let frac=1+Math.log2(logBailoutSquared/Math.log(lastZ2));let mix=frac*avg+(1-frac)*prevAvg;return mix*mixFactor}},computeBoundPointColorCurvature:function(n,precis,algorithm,x,y,useSmooth){const skipFirstIters=1;const maxIter=n;const mixFactor=1e5;const bailoutSquared=useSmooth?64*64:4;const logBailoutSquared=Math.log(bailoutSquared);let ix=0;let iy=0;let ixSq=0;let iySq=0;let ixTemp=0;let iter=0;let avgCount=0;let avg=0;let lastAdded=0;let lastZ2=0;let currentZ={x:0,y:0};let oneZ={x:0,y:0};let twoZ={x:0,y:0};while(iter<maxIter){ixSq=ix*ix;iySq=iy*iy;lastZ2=ixSq+iySq;twoZ=oneZ;oneZ=currentZ;currentZ={x:ix,y:iy};if(iter>skipFirstIters){let curveNum={x:currentZ.x-oneZ.x,y:currentZ.y-oneZ.y};let curveDen={x:oneZ.x-twoZ.x,y:oneZ.y-twoZ.y};let curveQuot=floatMath.complexDiv(curveNum,curveDen);if(curveQuot.x!=0){avgCount++;lastAdded=Math.abs(1.2*Math.atan(curveQuot.y/curveQuot.x));avg+=lastAdded}}if(lastZ2>bailoutSquared){break}ixTemp=x+(ixSq-iySq);iy=y+2*ix*iy;ix=ixTemp;iter++}if(iter>=maxIter){return windowCalcBackgroundColor}else{if(!useSmooth){return avg/avgCount}let prevAvg=(avg-lastAdded)/(avgCount-1);avg=avg/avgCount;let frac=1+Math.log2(logBailoutSquared/Math.log(lastZ2));let mix=frac*avg+(1-frac)*prevAvg;return mix*mixFactor}},computeReferenceOrbit:function(n,precis,algorithm,x,y,period,useSmooth,fnContext){const outputMath=selectMathInterfaceFromAlgorithm(algorithm);const outputIsFloatExp=outputMath.name=="floatexp";const useStripes=algorithm.includes("stripes");const periodLessThanN=period!==null&&period>0&&period<n;const maxIter=periodLessThanN?period+2:n;const two=infNum(2n,0n);const four=infNum(4n,0n);const sixteen=infNum(16n,0n);const bailoutSquared=useStripes?useSmooth?infNum(64n*64n*2n,0n):sixteen:useSmooth?infNum(32n*32n*2n,0n):sixteen;if(fnContext===null){fnContext={ix:infNum(0n,0n),iy:infNum(0n,0n),iter:0,orbit:[],status:"",done:false}}var ixSq=infNum(0n,0n);var iySq=infNum(0n,0n);var ixTemp=infNum(0n,0n);var statusIterCounter=0;try{while(fnContext.iter<maxIter){ixSq=infNumMul(fnContext.ix,fnContext.ix);iySq=infNumMul(fnContext.iy,fnContext.iy);if(infNumGt(infNumAdd(ixSq,iySq),bailoutSquared)){break}fnContext.orbit.push({x:outputMath.createFromInfNum(fnContext.ix),y:outputMath.createFromInfNum(fnContext.iy),xfxp:outputIsFloatExp?null:floatExpMath.createFromInfNum(fnContext.ix),yfxp:outputIsFloatExp?null:floatExpMath.createFromInfNum(fnContext.iy)});ixTemp=infNumAdd(x,infNumSub(ixSq,iySq));fnContext.iy=infNumAdd(y,infNumMul(two,infNumMul(fnContext.ix,fnContext.iy)));fnContext.ix=copyInfNum(ixTemp);fnContext.ix=infNumTruncateToLen(fnContext.ix,precis);fnContext.iy=infNumTruncateToLen(fnContext.iy,precis);fnContext.iter++;statusIterCounter++;if(statusIterCounter>=5e3){statusIterCounter=0;fnContext.status="computed "+Math.round(fnContext.iter*1e4/maxIter)/100+"% of reference orbit";console.log(fnContext.status);return fnContext}}if(periodLessThanN){const periodPlusTwoIter=fnContext.orbit.pop();const periodPlusOneIter=fnContext.orbit.pop();const firstIter=fnContext.orbit[0];const secondIter=fnContext.orbit[1];console.log("the full period of ["+period+"] iters has been computed, "+"where the orbit has ["+fnContext.orbit.length+"] iters, where the first orbit iter is (should be zero):\n",{x:outputMath.toExpString(firstIter.x),y:outputMath.toExpString(firstIter.y)}," and where the last orbit iter is:\n",{x:outputMath.toExpString(fnContext.orbit[fnContext.orbit.length-1].x),y:outputMath.toExpString(fnContext.orbit[fnContext.orbit.length-1].y)}," and where the next ["+(period+1)+"]th iteration (should be (~0, ~0)) would be at:\n",{x:outputMath.toExpString(periodPlusOneIter.x),y:outputMath.toExpString(periodPlusOneIter.y)}," and where the next ["+(period+2)+"]th iteration would be at:\n",{x:outputMath.toExpString(periodPlusTwoIter.x),y:outputMath.toExpString(periodPlusTwoIter.y)}," which should be equal to, or close to, the 1th (2nd) iter:\n",{x:outputMath.toExpString(secondIter.x),y:outputMath.toExpString(secondIter.y)})}fnContext.done=true;return fnContext}catch(e){console.log("ERROR CAUGHT when computing reference orbit at point (x, y, iter, maxIter): ["+infNumToString(x)+", "+infNumToString(y)+", "+fnContext.iter+", "+maxIter+"]:");console.log(e.name+": "+e.message+":\n"+e.stack.split("\n").slice(0,5).join("\n"));fnContext.done=true;return fnContext}},findMinibrotWithBallArithmetic1stOrderAndNewton:function(n,precis,algorithm,x,y,viewWidth,viewHeight,getNthIterationAndDerivative,newtonsMethod,fnContext){const math=infNumMath;let z;let r;const maxR=math.createFromNumber(1e5);if(fnContext===null){const r0init=math.min(math.createFromInfNum(viewWidth),math.createFromInfNum(viewHeight));const c0init={x:math.createFromInfNum(x),y:math.createFromInfNum(y)};fnContext={c0:c0init,r0:r0init,r0sq:math.mul(r0init,r0init),az:math.zero,k:1,newtonFnStatus:null,nucleus:null,status:"",done:false};z=math.complexRealMul(c0init,math.zero);r=r0init}else{z=fnContext.z;r=fnContext.r}let az=fnContext.az;const c0=fnContext.c0;const r0=fnContext.r0;const r0sq=fnContext.r0sq;while(fnContext.k<n){if(fnContext.newtonFnStatus===null){r=math.add(az,r);r=math.mul(r,r);r=math.sub(r,math.mul(az,az));r=math.add(r,r0);z=math.complexAdd(math.complexMul(z,z),c0);az=math.complexAbs(z);z.x=infNumTruncateToLen(z.x,precis);z.y=infNumTruncateToLen(z.y,precis);r=infNumTruncateToLen(r,precis);az=infNumTruncateToLen(az,precis)}if(math.gt(r,az)){if(fnContext.newtonFnStatus===null){fnContext.z=z;fnContext.r=r;fnContext.az=az;console.log("period found with 1st-order ball arithmetic:",fnContext.k)}if(fnContext.newtonFnStatus===null||!fnContext.newtonFnStatus.done){fnContext.newtonFnStatus=newtonsMethod(fnContext.k,x,y,precis,getNthIterationAndDerivative,fnContext.newtonFnStatus);if(!fnContext.newtonFnStatus.done){fnContext.status=fnContext.newtonFnStatus.status;return fnContext}}fnContext.nucleus=fnContext.newtonFnStatus.c;fnContext.newtonFnStatus=null;if(math.lt(math.complexAbsSquared(math.complexSub(fnContext.nucleus,c0)),r0sq)){console.log("found on-screen ref x/y/period!");fnContext.nucleus.period=fnContext.k;fnContext.done=true;return fnContext}else{console.log("newton nucleus with period ["+fnContext.k+"] is off screen!");fnContext.nucleus=null}}if(math.gt(az,maxR)||math.gt(r,maxR)){console.log("1st-order ball arithmetic escaped at iteration:",fnContext.k);fnContext.nucleus=null;fnContext.done=true;return fnContext}fnContext.k++;if(fnContext.k%5e3===0){fnContext.z=z;fnContext.r=r;fnContext.az=az;fnContext.status="1st-order ball arithmetic at iter. ["+fnContext.k.toLocaleString()+"]";console.log("1st-order ball arithmetic at iteration:",fnContext.k);return fnContext}}fnContext.nucleus=null;fnContext.done=true;return fnContext},getNthIterationAndDerivative:function(n,x,y,precis,fnContext){const bailoutSquared=infNum(64n*64n*2n,0n);if(fnContext===null){fnContext={z:{x:infNum(0n,0n),y:infNum(0n,0n)},dz:{x:infNum(0n,0n),y:infNum(0n,0n)},c:{x:copyInfNum(x),y:copyInfNum(y)},iter:0,status:"",done:false}}var ixSq=infNum(0n,0n);var iySq=infNum(0n,0n);var ixTemp=infNum(0n,0n);var statusIterCounter=0;try{while(fnContext.iter<n){fnContext.dz=infNumMath.complexRealAdd(infNumMath.complexRealMul(infNumMath.complexMul(fnContext.z,fnContext.dz),infNumMath.two),infNumMath.one);ixSq=infNumMul(fnContext.z.x,fnContext.z.x);iySq=infNumMul(fnContext.z.y,fnContext.z.y);if(infNumGt(infNumAdd(ixSq,iySq),bailoutSquared)){break}fnContext.dz.x=infNumTruncateToLen(fnContext.dz.x,precis);fnContext.dz.y=infNumTruncateToLen(fnContext.dz.y,precis);ixTemp=infNumAdd(x,infNumSub(ixSq,iySq));fnContext.z.y=infNumAdd(y,infNumMul(infNumMath.two,infNumMul(fnContext.z.x,fnContext.z.y)));fnContext.z.x=copyInfNum(ixTemp);fnContext.z.x=infNumTruncateToLen(fnContext.z.x,precis);fnContext.z.y=infNumTruncateToLen(fnContext.z.y,precis);fnContext.iter++;statusIterCounter++;if(statusIterCounter>=1e4){statusIterCounter=0;fnContext.status="at "+Math.round(fnContext.iter*1e4/n)/100+"% of orbit";console.log(fnContext.status);return fnContext}}fnContext.status="at "+Math.round(fnContext.iter*1e4/n)/100+"% of orbit";fnContext.done=true;return fnContext}catch(e){console.log("ERROR CAUGHT when computing Nth iteration and derivative (x, y, iter, maxIter): ["+infNumToString(x)+", "+infNumToString(y)+", "+fnContext.iter+", "+n+"]:");console.log(e.name+": "+e.message+":\n"+e.stack.split("\n").slice(0,5).join("\n"));fnContext.done=true;return fnContext}},newtonsMethod:function(period,x,y,precis,getNthIterationAndDerivative,fnCtx){const maxSteps=24;const closeEnoughPrecis=Math.min(precis-3,Math.floor(precis*.995));if(fnCtx===null){fnCtx={nthIterState:null,c:{x:copyInfNum(x),y:copyInfNum(y)},i:0,status:"",done:false}}let step;let cPrev;while(fnCtx.i<maxSteps){if(fnCtx.nthIterState===null||!fnCtx.nthIterState.done){fnCtx.nthIterState=getNthIterationAndDerivative(period,fnCtx.c.x,fnCtx.c.y,precis,fnCtx.nthIterState);fnCtx.status="for "+numberWithOrdinalSuffix(fnCtx.i+1)+" Newton's iteration, "+fnCtx.nthIterState.status;return fnCtx}cPrev=fnCtx.c;step=infNumMath.complexDiv(fnCtx.nthIterState.z,fnCtx.nthIterState.dz,precis);fnCtx.c=infNumMath.complexSub(fnCtx.c,step);if(infNumApproxEq(fnCtx.c.x,cPrev.x,closeEnoughPrecis)&&infNumApproxEq(fnCtx.c.y,cPrev.y,closeEnoughPrecis)){console.log("newton's method stopped during the ["+numberWithOrdinalSuffix(fnCtx.i+1)+"] iteration because z/dz got tiny enough to be negligible (compared with infNumApproxEq() to have the same "+closeEnoughPrecis+" most-significant digits)");break}if(infNumApproxEqSimple(fnCtx.c.x,cPrev.x,closeEnoughPrecis)&&infNumApproxEqSimple(fnCtx.c.y,cPrev.y,closeEnoughPrecis)){console.log("newton's method stopped during the ["+numberWithOrdinalSuffix(fnCtx.i+1)+"] iteration because z/dz got tiny enough to be negligible (compared with infNumApproxEqSimple() to have the same "+closeEnoughPrecis+" most-significant digits)");break}if((fnCtx.i+1)%10===1){console.log("after the ["+numberWithOrdinalSuffix(fnCtx.i+1)+"] iteration of newton's method, c is:",{x:infNumExpString(fnCtx.c.x),y:infNumExpString(fnCtx.c.y)})}fnCtx.nthIterState=null;fnCtx.i++}fnCtx.done=true;return fnCtx},computeSaCoefficients:function(precision,algorithm,referenceX,referenceY,referenceOrbit,windowEdges,fnContext){const math=floatExpMath;const algoMath=selectMathInterfaceFromAlgorithm(algorithm);const algoMathIsFloatExp=algoMath.name=="floatexp";if(fnContext===null){let nTerms=3;let dimDiv=3;try{let sapx=algorithm.split("-").find((e=>e.startsWith("sapx"))).substring(4).split(".");nTerms=Math.max(3,Math.min(128,parseInt(BigInt(sapx[0]).toString())));dimDiv=Math.max(1,Math.min(7,parseInt(BigInt(sapx[1]).toString())))}catch{}let testPoints=[];let py=windowEdges.top;let xStep=infNumDiv(infNumSub(windowEdges.right,windowEdges.left),infNum(BigInt(dimDiv),0n),precision);let yStep=infNumDiv(infNumSub(windowEdges.top,windowEdges.bottom),infNum(BigInt(dimDiv),0n),precision);for(let i=0;i<=dimDiv;i++){let px=windowEdges.left;for(let j=0;j<=dimDiv;j++){testPoints.push({x:copyInfNum(px),y:copyInfNum(py)});px=infNumAdd(px,xStep)}py=infNumAdd(py,yStep)}let terms=new Array(nTerms).fill({x:math.zero,y:math.zero});terms[0]={x:math.one,y:math.zero};fnContext={nTerms:nTerms,termShrinkCutoff:math.createFromNumber(1e3*1e3),testPoints:testPoints,terms:terms,itersToSkip:-1,refOrbitIter:0,saCoefficients:{itersToSkip:0,coefficients:[]},status:"",done:false}}if(fnContext.nTerms<=0){console.log("series approximation has 0 or fewer terms in the algorithm name ["+algorithm+"], so NOT doing SA");fnContext.done=true;return fnContext}let twoRefIter=null;const nextTerms=new Array(fnContext.nTerms);let i=fnContext.refOrbitIter;let statusIterCounter=0;for(;i<referenceOrbit.length-3;i++){twoRefIter=algoMathIsFloatExp?math.complexRealMul(referenceOrbit[i],math.two):math.complexRealMul({x:referenceOrbit[i].xfxp,y:referenceOrbit[i].yfxp},math.two);for(let k=0;k<fnContext.nTerms;k++){if(k===0){nextTerms[k]=math.complexRealAdd(math.complexMul(twoRefIter,fnContext.terms[k]),math.one)}else if(k%2===0){nextTerms[k]=math.complexMul(twoRefIter,fnContext.terms[k]);for(let up=0,dn=k-1;up<dn;up++,dn--){nextTerms[k]=math.complexAdd(nextTerms[k],math.complexRealMul(math.complexMul(fnContext.terms[up],fnContext.terms[dn]),math.two))}}else{nextTerms[k]=math.complexMul(twoRefIter,fnContext.terms[k]);for(let up=0,dn=k-1;up<=dn;up++,dn--){if(up===dn){nextTerms[k]=math.complexAdd(nextTerms[k],math.complexMul(fnContext.terms[up],fnContext.terms[dn]))}else{nextTerms[k]=math.complexAdd(nextTerms[k],math.complexRealMul(math.complexMul(fnContext.terms[up],fnContext.terms[dn]),math.two))}}}}let validTestPoints=0;for(let p=0;p<fnContext.testPoints.length;p++){let deltaC={x:math.createFromInfNum(infNumSub(fnContext.testPoints[p].x,referenceX)),y:math.createFromInfNum(infNumSub(fnContext.testPoints[p].y,referenceY))};let coefTermsAreValid=false;for(let j=1;j<fnContext.nTerms;j++){let deltaCpower=structuredClone(deltaC);let firstSmallest=null;let secondLargest=null;for(let k=0;k<j;k++){let wholeTerm=math.complexAbsSquared(math.complexMul(deltaCpower,nextTerms[k]));if(firstSmallest===null||math.lt(wholeTerm,firstSmallest)){firstSmallest=structuredClone(wholeTerm)}deltaCpower=math.complexMul(deltaCpower,deltaC)}for(let k=j;k<fnContext.nTerms;k++){let wholeTerm=math.complexAbsSquared(math.complexMul(deltaCpower,nextTerms[k]));if(secondLargest===null||math.gt(wholeTerm,secondLargest)){secondLargest=structuredClone(wholeTerm)}deltaCpower=math.complexMul(deltaCpower,deltaC)}if(secondLargest.v===0n){coefTermsAreValid=true;break}let ratio=math.div(firstSmallest,secondLargest);if(math.gt(ratio,fnContext.termShrinkCutoff)){coefTermsAreValid=true;break}}if(coefTermsAreValid){validTestPoints++}else{console.log("SA test point ["+p+"] is not valid at iteration ["+i+"]");break}}if(validTestPoints<fnContext.testPoints.length){fnContext.itersToSkip=i;fnContext.done=true;console.log("SA stopping with ["+i+"] valid iterations");break}for(let j=0;j<fnContext.nTerms;j++){fnContext.terms[j]=nextTerms[j]}statusIterCounter++;if(statusIterCounter>=5e3){fnContext.status="can skip "+Math.round(i*1e4/referenceOrbit.length)/100+"% of reference orbit";console.log("all test points are valid for skipping ["+i.toLocaleString()+"] iterations");fnContext.refOrbitIter=i+1;return fnContext}}fnContext.done=true;if(fnContext.itersToSkip<0){console.log("able to skip ALL ["+i+"/"+referenceOrbit.length+"] iterations of the reference orbit with ["+fnContext.nTerms+"]-term SA... hmm... perhaps N is set too low");fnContext.saCoefficients={itersToSkip:i,coefficients:fnContext.terms}}else{console.log("able to skip ["+fnContext.itersToSkip+"] iterations with ["+fnContext.nTerms+"]-term SA");fnContext.saCoefficients={itersToSkip:fnContext.itersToSkip,coefficients:fnContext.terms}}return fnContext},computeBlaTables:function(algorithm,epsilon,referenceOrbit,referencePx,referencePy,windowEdges,fnContext){const math=selectMathInterfaceFromAlgorithm(algorithm);const minIter=1;const maxIter=referenceOrbit.length-3;let calcsDoneThisStatusUpdate=0;const calcsPerStatusUpdate=1e4;const lowLevelsToDelete=2;if(fnContext===null){let refDeltaCX=math.createFromInfNum(infNumSub(windowEdges.left,referencePx));let refDeltaCY=math.createFromInfNum(infNumSub(windowEdges.bottom,referencePy));let maxAbsC=math.complexAbs({x:refDeltaCX,y:refDeltaCY});refDeltaCX=math.createFromInfNum(infNumSub(windowEdges.right,referencePx));maxAbsC=math.max(maxAbsC,math.complexAbs({x:refDeltaCX,y:refDeltaCY}));refDeltaCY=math.createFromInfNum(infNumSub(windowEdges.top,referencePy));maxAbsC=math.max(maxAbsC,math.complexAbs({x:refDeltaCX,y:refDeltaCY}));refDeltaCX=math.createFromInfNum(infNumSub(windowEdges.left,referencePx));maxAbsC=math.max(maxAbsC,math.complexAbs({x:refDeltaCX,y:refDeltaCY}));const algoEpsilon=getBLAEpsilonFromAlgorithm(algorithm);const infNumEpsilon=algoEpsilon===null?epsilon:algoEpsilon;fnContext={infNumEpsilon:infNumEpsilon,epsilon:math.createFromInfNum(infNumEpsilon),blasByRefIter:new Map,blas:{byNthIter:[],iterToNthDivisor:lowLevelsToDelete**2},maxAbsC:maxAbsC,calcTotalBlas:maxIter*2,calcBLAsDone:0,calcLevel:0,calcRefIterBLA:minIter,status:"",done:false};console.log("using epsilon: "+math.toExpString(fnContext.epsilon))}const totalLevels=Math.floor(Math.log2(maxIter))+1;let level=fnContext.calcLevel;let refIter=fnContext.calcRefIterBLA;for(;level<totalLevels;level++){let levelItersToSkip=2**level;let prevLevelItersToSkip=2**(level-1);if(levelItersToSkip>maxIter){console.log("stopping computing BLAs at level ["+level+"] because levelItersToSkip ["+levelItersToSkip+"] > ["+maxIter+"] ref iters");break}for(;refIter<maxIter-levelItersToSkip;refIter+=levelItersToSkip){if(level==0){let bla={a:math.complexRealMul(referenceOrbit[refIter],math.two),b:{x:math.one,y:math.zero},r:null,r2:null,itersToSkip:levelItersToSkip};let r;let absA=math.complexAbs(bla.a);let absB=math.complexAbs(bla.b);let absZ=math.complexAbs(referenceOrbit[refIter]);r=math.mul(fnContext.epsilon,absZ);r=math.sub(r,math.mul(absB,fnContext.maxAbsC));r=math.div(r,absA);r=math.max(math.zero,r);bla.r=r;bla.r2=math.mul(r,r);fnContext.blasByRefIter.set(refIter,[bla]);calcsDoneThisStatusUpdate++}else if(refIter+levelItersToSkip<maxIter){let x=fnContext.blasByRefIter.get(refIter).find((e=>e.itersToSkip==prevLevelItersToSkip));let y=fnContext.blasByRefIter.get(refIter+prevLevelItersToSkip).find((e=>e.itersToSkip==prevLevelItersToSkip));let bla={a:math.complexMul(x.a,y.a),b:math.complexAdd(math.complexMul(x.b,y.a),y.b),r:null,r2:null,itersToSkip:levelItersToSkip};let r=math.min(x.r,math.max(math.zero,math.div(math.sub(y.r,math.mul(math.complexAbs(bla.b),fnContext.maxAbsC)),math.complexAbs(bla.a))));bla.r=r;bla.r2=math.mul(r,r);delete x.r;delete y.r;fnContext.blasByRefIter.get(refIter).unshift(bla);calcsDoneThisStatusUpdate++}if(calcsDoneThisStatusUpdate>=calcsPerStatusUpdate){fnContext.calcLevel=level;fnContext.calcBLAsDone=fnContext.calcBLAsDone+calcsDoneThisStatusUpdate;fnContext.calcRefIterBLA=refIter+levelItersToSkip;fnContext.status="computed "+Math.round(fnContext.calcBLAsDone*1e4/fnContext.calcTotalBlas)/100+"% of BLAs";return fnContext}}refIter=minIter}fnContext.done=true;console.log("before deleting the lowest [",lowLevelsToDelete,"] levels, we have BLAs at [",fnContext.blasByRefIter.size,"] iterations");let totalDeletedBLAs=0;let blasAtRefIter;let bla;for(let deleteLevel=0;deleteLevel<lowLevelsToDelete;deleteLevel++){let levelItersToSkip=2**deleteLevel;for(let deleteRefIter=1;deleteRefIter<maxIter;deleteRefIter+=levelItersToSkip){blasAtRefIter=fnContext.blasByRefIter.get(deleteRefIter);if(blasAtRefIter===undefined){continue}if(blasAtRefIter.length>0){bla=blasAtRefIter.pop();if(bla.itersToSkip!=levelItersToSkip){console.log("somehow, for ref iter "+deleteRefIter+", was going to remove a "+bla.itersToSkip+"-iter BLA when trying to remove BLAs with ",levelItersToSkip," iters");blasAtRefIter.push(bla)}totalDeletedBLAs++}if(blasAtRefIter.length==0){fnContext.blasByRefIter.delete(deleteRefIter)}}}console.log("deleted ["+totalDeletedBLAs+"] total BLAs in the lowest ["+lowLevelsToDelete+"] levels");console.log("after deleting the lowest [",lowLevelsToDelete,"] levels, we have BLAs at [",fnContext.blasByRefIter.size,"] iterations");for(const kv of fnContext.blasByRefIter){if(kv[0]<20){let index=(kv[0]-1)/fnContext.blas.iterToNthDivisor;console.log("iteration",kv[0],"becomes array index",index)}fnContext.blas.byNthIter[(kv[0]-1)/fnContext.blas.iterToNthDivisor]=kv[1]}delete fnContext.blasByRefIter;return fnContext},computeBoundPointColorPerturbOrBla:function(n,precis,dx,dy,algorithm,referenceX,referenceY,referenceOrbit,blaTables,saCoefficients,useSmooth){const math=selectMathInterfaceFromAlgorithm(algorithm);const useStripes=algorithm.includes("stripes");const oneHalf=math.createFromNumber(.5);let stripeDensity=math.createFromNumber(6);let userStripeDensity;try{userStripeDensity=parseFloat(algorithm.split("-").find((e=>e.startsWith("stripedensity"))).substring(13))}catch(e){}if(userStripeDensity!==undefined&&userStripeDensity>=1&&userStripeDensity<=10){stripeDensity=math.createFromNumber(userStripeDensity)}const mixFactor=1e5;const bailoutSquared=useStripes?useSmooth?math.createFromNumber(64*64):math.four:useSmooth?math.createFromNumber(32*32):math.four;const logBailoutSquared=math.log(bailoutSquared);const useBla=algorithm.includes("bla-");const useSa=algorithm.includes("sapx");const maxIter=n;let deltaC={x:dx,y:dy};const deltaCAbs=math.complexAbs(deltaC);let iter=0;const maxReferenceIter=referenceOrbit.length-1;let referenceIter=0;let deltaZ={x:math.zero,y:math.zero};let z=null;let zAbs=null;let deltaZAbs=null;if(useSa&&saCoefficients!==null&&saCoefficients.itersToSkip>0){let deltaCFloatExp={x:math.name=="floatexp"?structuredClone(deltaC.x):floatExpMath.createFromExpString(math.toExpString(deltaC.x)),y:math.name=="floatexp"?structuredClone(deltaC.y):floatExpMath.createFromExpString(math.toExpString(deltaC.y))};let deltaZFloatExp={x:floatExpMath.zero,y:floatExpMath.zero};let deltaCpower=structuredClone(deltaCFloatExp);for(let i=0;i<saCoefficients.coefficients.length;i++){deltaZFloatExp=floatExpMath.complexAdd(deltaZFloatExp,floatExpMath.complexMul(saCoefficients.coefficients[i],deltaCpower));deltaCpower=floatExpMath.complexMul(deltaCpower,deltaCFloatExp)}iter+=saCoefficients.itersToSkip;referenceIter+=saCoefficients.itersToSkip;if(math.name=="floatexp"){deltaZ=deltaZFloatExp}else{deltaZ={x:math.createFromExpString(floatExpMath.toExpString(deltaZFloatExp.x)),y:math.createFromExpString(floatExpMath.toExpString(deltaZFloatExp.y))}}deltaZAbs=math.complexAbsSquared(deltaZ)}let blaItersSkipped=0;let blaSkips=0;try{let lastZ2=math.zero;let lastAdded=math.zero;let avg=math.zero;let avgCount=0;let foundBLA;let blasAtRefIter;let blaItersToSkip;let blaTestResult;let foundValidBLA;while(iter<maxIter){foundValidBLA=false;if(useBla&&(referenceIter&3)===1){blasAtRefIter=blaTables.byNthIter[(referenceIter-1)/blaTables.iterToNthDivisor];if(blasAtRefIter===undefined){}else{blaTestResult=searchForBestBLA(blasAtRefIter,deltaZAbs,math);foundBLA=blaTestResult.bestValidBLA;foundValidBLA=foundBLA!==false;if(foundValidBLA){blaItersToSkip=foundBLA.itersToSkip;deltaZ=math.complexAdd(math.complexMul(foundBLA.a,deltaZ),math.complexMul(foundBLA.b,deltaC));iter+=blaItersToSkip;referenceIter+=blaItersToSkip;blaItersSkipped+=blaItersToSkip;blaSkips++}}}if(!foundValidBLA){deltaZ=math.complexAdd(math.complexAdd(math.complexMul(math.complexRealMul(referenceOrbit[referenceIter],math.two),deltaZ),math.complexMul(deltaZ,deltaZ)),deltaC);iter++;referenceIter++}if(referenceIter>maxReferenceIter){referenceIter=0;z=math.complexAdd(referenceOrbit[referenceIter],deltaZ);deltaZ=z}else{z=math.complexAdd(referenceOrbit[referenceIter],deltaZ)}if(useStripes){avgCount++;lastAdded=math.add(math.mul(oneHalf,math.sin(math.mul(stripeDensity,math.atan(z.y,z.x)))),oneHalf);avg=math.add(avg,lastAdded)}zAbs=math.complexAbsSquared(z);lastZ2=zAbs;if(math.gt(zAbs,bailoutSquared)){iter--;break}deltaZAbs=math.complexAbsSquared(deltaZ);if(math.lt(zAbs,deltaZAbs)){deltaZ=z;referenceIter=0}}if(iter>=maxIter){return{colorpct:windowCalcBackgroundColor,blaItersSkipped:blaItersSkipped,blaSkips:blaSkips}}else{if(useStripes){if(!useSmooth){avg=math.div(avg,math.createFromNumber(avgCount));avg=parseFloat(math.toExpString(avg));return{colorpct:avg,blaItersSkipped:blaItersSkipped,blaSkips:blaSkips}}let prevAvg=math.div(math.sub(avg,lastAdded),math.createFromNumber(avgCount-1));avg=math.div(avg,math.createFromNumber(avgCount));let frac=1+Math.log2(logBailoutSquared/math.log(lastZ2));frac=math.createFromNumber(frac);let mix=math.sub(math.one,frac);mix=math.mul(mix,prevAvg);mix=math.add(mix,math.mul(frac,avg));mix*=mixFactor;return{colorpct:mix,blaItersSkipped:blaItersSkipped,blaSkips:blaSkips}}if(useSmooth){let fracIter=math.log(math.complexAbsSquared(z))/2;fracIter=Math.log(fracIter/Math.LN2)/Math.LN2;iter+=1-fracIter}return{colorpct:iter,blaItersSkipped:blaItersSkipped,blaSkips:blaSkips}}}catch(e){console.log("ERROR CAUGHT when calculating ["+algorithm+"] pixel color",{dx:math.toExpString(dx),dy:math.toExpString(dy),iter:iter,maxIter:maxIter,refIter:referenceIter,maxRefIter:maxReferenceIter});console.log(e.name+": "+e.message+":\n"+e.stack.split("\n").slice(0,5).join("\n"));return{colorpct:windowCalcIgnorePointColor,blaItersSkipped:blaItersSkipped,blaSkips:blaSkips}}},forcedDefaults:{n:100,mag:infNum(1n,0n),centerX:createInfNum("-0.65"),centerY:infNum(0n,0n)},magnificationFactor:infNum(3n,0n),privContext:{usesImaginaryCoordinates:true,adjustPrecision:function(scale,usingWorkers,algorithm){const precisScale=infNumTruncateToLen(scale,8);const ret={roughScale:infNumExpString(precisScale),precision:12,algorithm:"basic-float"};if(algorithm==="auto-stripes"){if(infNumGe(precisScale,createInfNum("3e13"))){ret.algorithm="perturb-stripes-stripedensity6-float"}else{ret.algorithm="basic-stripes-stripedensity6-float"}}else if(algorithm==="bla-auto"){if(infNumGe(precisScale,createInfNum("1e304"))){ret.algorithm="bla-floatexp"}else if(infNumGe(precisScale,createInfNum("1e25"))){ret.algorithm="bla-float"}else if(infNumGe(precisScale,createInfNum("3e13"))){ret.algorithm="perturb-float"}else{ret.algorithm="basic-float"}}else{if(infNumGe(precisScale,createInfNum("1e800"))){ret.algorithm="perturb-sapx32-floatexp"}else if(infNumGe(precisScale,createInfNum("1e500"))){ret.algorithm="perturb-sapx16-floatexp"}else if(infNumGe(precisScale,createInfNum("1e304"))){ret.algorithm="perturb-sapx8-floatexp"}else if(infNumGe(precisScale,createInfNum("1e200"))){ret.algorithm="perturb-sapx6-float"}else if(infNumGe(precisScale,createInfNum("1e100"))){ret.algorithm="perturb-sapx4-float"}else if(infNumGe(precisScale,createInfNum("3e13"))){ret.algorithm="perturb-float"}}if(infNumLt(precisScale,createInfNum("1e3"))){ret.precision=12}else if(infNumLt(precisScale,createInfNum("2e6"))){ret.precision=12}else if(infNumLt(precisScale,createInfNum("3e13"))){ret.precision=20}else if(infNumLt(precisScale,createInfNum("1e40"))){ret.precision=Math.floor(infNumMagnitude(precisScale)*1.7)}else if(infNumLt(precisScale,createInfNum("1e60"))){ret.precision=Math.floor(infNumMagnitude(precisScale)*1.5)}else if(infNumLt(precisScale,createInfNum("1e100"))){ret.precision=Math.floor(infNumMagnitude(precisScale)*1.4)}else if(infNumLt(precisScale,createInfNum("1e150"))){ret.precision=Math.floor(infNumMagnitude(precisScale)*1.25)}else if(infNumLt(precisScale,createInfNum("1e200"))){ret.precision=Math.floor(infNumMagnitude(precisScale)*1.1)}else{ret.precision=Math.floor(infNumMagnitude(precisScale)*1.05)}if(!usingWorkers){if(algorithm=="auto-stripes"){if(infNumGe(precisScale,createInfNum("3e13"))){ret.algorithm="perturb-stripes-stripedensity6-float"}else{ret.algorithm="basic-stripes-stripedensity6-float"}}else{if(infNumGe(precisScale,createInfNum("1e304"))){ret.algorithm="perturb-floatexp"}else if(infNumGe(precisScale,createInfNum("3e13"))){ret.algorithm="perturb-float"}else{ret.algorithm="basic-float"}}}console.log("default mandelbrot settings for scale:",ret);return ret},listAlgorithms:function(){return[{algorithm:"auto",name:"automatic"},{algorithm:"auto-stripes",name:"automatic with stripes coloring"},{algorithm:"basic-float",name:"basic escape time, floating point"},{algorithm:"basic-floatexp",name:"basic escape time, floatexp"},{algorithm:"perturb-float",name:"perturbation theory, floating point"},{algorithm:"perturb-floatexp",name:"perturbation theory, floatexp"},{algorithm:"perturb-sapx4-float",name:"perturb. w/series approx., floating point"},{algorithm:"perturb-sapx8-floatexp",name:"perturb. w/series approx., floatexp"},{algorithm:"basic-stripes-stripedensity6-float",name:"esc. time w/stripes coloring, floating pt."},{algorithm:"basic-stripes-stripedensity2-float",name:"esc. time w/wide stripes coloring, floating pt."},{algorithm:"basic-stripes-stripedensity8-float",name:"esc. time w/narrow stripes coloring, floating pt."},{algorithm:"perturb-stripes-stripedensity6-float",name:"perturb. w/stripes coloring, floating pt."},{algorithm:"bla-auto",name:"automatic with BLA"},{algorithm:"perturb-sapx6.4-floatexp-sigdig64",name:"custom"}]},minScale:createInfNum("20")}},{name:"Primes-1-Step-90-turn",pageTitle:"Primes",calcFrom:"sequence",desc:'Drawn with a simple <a target="blank" href="https://en.wikipedia.org/wiki/Turtle_graphics">'+"turtle graphics</a> pattern: move 1 step forward per integer, but for primes, turn 90 degrees clockwise before moving.",gradientType:"pct",computePointsAndLength:function(privContext){var resultPoints=[];var resultLength=0;if(historyParams.n>5e6){historyParams.n=5e6}const params=historyParams;resultPoints.push(getPoint(0,0));var nextPoint=getPoint(0,0);privContext.direction=0;for(var i=1;i<params.n;i++){if(isPrime(i)){nextPoint.v={prime:i.toLocaleString()};resultPoints.push(nextPoint);privContext.direction=privContext.changeDirection(privContext.direction)}nextPoint=privContext.computeNextPoint(privContext.direction,i,nextPoint.x,nextPoint.y,{last:(i+1).toLocaleString()});resultLength+=1}if(isPrime(parseInt(nextPoint.v.last))){nextPoint.v={prime:nextPoint.v.last}}resultPoints.push(nextPoint);return{points:resultPoints,length:resultLength}},forcedDefaults:{n:6e4,mag:infNum(1n,0n),centerX:createInfNum("-240"),centerY:createInfNum("288")},magnificationFactor:infNum(850n,0n),privContext:{direction:0,changeDirection:function(dir){return changeDirectionDegrees(dir,90)},computeNextPoint:function(dir,n,x,y,v){return computeNextPointDegrees(dir,1,x,y,v)}}},{name:"Primes-1-Step-45-turn",pageTitle:"Primes",calcFrom:"sequence",desc:'Drawn with a simple <a target="blank" href="https://en.wikipedia.org/wiki/Turtle_graphics">'+"turtle graphics</a> pattern: move 1 step forward per integer, but for primes, turn 45 degrees "+"clockwise before moving. When moving diagonally, we move 1 step on both the x and y axes, so we're "+"actually moving ~1.414 steps diagonally.",gradientType:"pct",computePointsAndLength:function(privContext){var resultPoints=[];var resultLength=0;if(historyParams.n>5e6){historyParams.n=5e6}const params=historyParams;resultPoints.push(getPoint(0,0));var nextPoint=getPoint(0,0);privContext.direction=315;for(var i=1;i<params.n;i++){if(isPrime(i)){nextPoint.v={prime:i.toLocaleString()};resultPoints.push(nextPoint);privContext.direction=privContext.changeDirection(privContext.direction)}nextPoint=privContext.computeNextPoint(privContext.direction,i,nextPoint.x,nextPoint.y,{last:(i+1).toLocaleString()});resultLength+=1}if(isPrime(parseInt(nextPoint.v.last))){nextPoint.v={prime:nextPoint.v.last}}resultPoints.push(nextPoint);return{points:resultPoints,length:resultLength}},forcedDefaults:{n:6e4,mag:infNum(1n,0n),centerX:infNum(0n,0n),centerY:infNum(415n,0n)},magnificationFactor:infNum(1600n,0n),privContext:{direction:0,changeDirection:function(dir){return changeDirectionDegrees(dir,45)},computeNextPoint:function(dir,n,x,y,v){return computeNextPointDegrees(dir,1,x,y,v)}}},{name:"Squares-1-Step-90-turn",pageTitle:"Squares",calcFrom:"sequence",desc:'Drawn with a simple <a target="blank" href="https://en.wikipedia.org/wiki/Turtle_graphics">'+"turtle graphics</a> pattern: move 1 step forward per integer, but for perfect squares, turn 90 "+"degrees clockwise before moving.",gradientType:"pct",computePointsAndLength:function(privContext){var resultPoints=[];var resultLength=0;if(historyParams.n>1e6){historyParams.n=1e6}const params=historyParams;var nextPoint=getPoint(0,0);privContext.direction=270;for(var i=1;i<params.n;i+=1){if(privContext.isSquare(i)){resultPoints.push(nextPoint);privContext.direction=privContext.changeDirection(privContext.direction)}nextPoint=privContext.computeNextPoint(privContext.direction,i,nextPoint.x,nextPoint.y,{square:(i+1).toLocaleString()});resultLength+=1}if(!privContext.isSquare(parseInt(nextPoint.v.square))){nextPoint.v={last:nextPoint.v.square}}resultPoints.push(nextPoint);return{points:resultPoints,length:resultLength}},forcedDefaults:{n:5e3,mag:infNum(1n,0n),centerX:infNum(0n,0n),centerY:infNum(0n,0n)},magnificationFactor:infNum(175n,0n),privContext:{direction:0,changeDirection:function(dir){return changeDirectionDegrees(dir,90)},computeNextPoint:function(dir,n,x,y,v){return computeNextPointDegrees(dir,1,x,y,v)},isSquare:function(n){const sqrt=Math.sqrt(n);return sqrt==Math.trunc(sqrt)}}},{name:"Squares-1-Step-45-turn",pageTitle:"Squares",calcFrom:"sequence",desc:'Drawn with a simple <a target="blank" href="https://en.wikipedia.org/wiki/Turtle_graphics">'+"turtle graphics</a> pattern: move 1 step forward per integer, but for perfect squares, turn 45 "+"degrees clockwise before moving.  When moving diagonally, we move 1 step on both the x and y axes, "+"so we're actually moving ~1.414 steps diagonally.",gradientType:"pct",computePointsAndLength:function(privContext){var resultPoints=[];var resultLength=0;const diagHypot=Math.sqrt(2);if(historyParams.n>1e6){historyParams.n=1e6}const params=historyParams;var nextPoint=getPoint(0,0);privContext.direction=270;for(var i=1;i<params.n;i+=1){if(privContext.isSquare(i)){resultPoints.push(nextPoint);privContext.direction=privContext.changeDirection(privContext.direction)}nextPoint=privContext.computeNextPoint(privContext.direction,i,nextPoint.x,nextPoint.y,{square:(i+1).toLocaleString()});resultLength+=privContext.direction%90==0?1:diagHypot}if(!privContext.isSquare(parseInt(nextPoint.v.square))){nextPoint.v={last:nextPoint.v.square}}resultPoints.push(nextPoint);return{points:resultPoints,length:resultLength}},forcedDefaults:{n:5e3,mag:infNum(1n,0n),centerX:infNum(0n,0n),centerY:infNum(0n,0n)},magnificationFactor:infNum(500n,0n),privContext:{direction:0,changeDirection:function(dir){return changeDirectionDegrees(dir,45)},computeNextPoint:function(dir,n,x,y,v){return computeNextPointDegrees(dir,1,x,y,v)},isSquare:function(n){const sqrt=Math.sqrt(n);return sqrt==Math.trunc(sqrt)}}},{name:"Primes-X-Y-neg-mod-3",pageTitle:"Primes",calcFrom:"sequence",desc:"Where each plotted point <code>(x,y)</code> consists of the primes, in order.  "+"Those points are (2,3), (5,7), (11,13), and so on.<br/><br/>"+"Then we take the sum of the digits of both the <code>x</code> and <code>y</code> of each point.<br/>"+"If that sum, mod 3, is 1, the <code>x</code> is negated.<br/>"+"If that sum, mod 3, is 2, the <code>y</code> is negated.<br/><br/>"+"After applying the negation rule, the first three plotted points become:<br/>"+"<code>(2,3)&nbsp;&nbsp;→ sum digits = 5&nbsp;&nbsp;mod 3 = 2 → -y → (2,-3)</code><br/>"+"<code>(5,7)&nbsp;&nbsp;→ sum digits = 12 mod 3 = 0 →&nbsp;&nbsp;&nbsp;&nbsp;→ (5,7)</code><br/>"+"<code>(11,13)→ sum digits = 6&nbsp;&nbsp;mod 3 = 0 →&nbsp;&nbsp;&nbsp;&nbsp;→ (11,13)</code>",gradientType:"pct",computePointsAndLength:function(privContext){var resultPoints=[];var resultLength=0;if(historyParams.n>1e6){historyParams.n=1e6}const params=historyParams;var lastX=-1;var lastPoint=getPoint(0,0);resultPoints.push(lastPoint);for(var i=1;i<params.n;i+=1){if(!isPrime(i)){continue}if(lastX==-1){lastX=i}else{var thisY=i;const digits=(lastX.toString()+thisY.toString()).split("");var digitsSum=0;for(var j=0;j<digits.length;j++){digitsSum+=digits[j]}const digitsSumMod4=digitsSum%3;if(digitsSumMod4==1){lastX=lastX*-1}else if(digitsSumMod4==2){thisY=thisY*-1}const nextPoint=getPoint(parseFloat(lastX),parseFloat(thisY),{prime:i.toLocaleString()});resultLength+=Math.hypot(nextPoint.x-lastPoint.x,nextPoint.y-lastPoint.y);resultPoints.push(nextPoint);lastX=-1;lastPoint=nextPoint}}return{points:resultPoints,length:resultLength}},forcedDefaults:{n:5e3,mag:infNum(1n,0n),centerX:infNum(0n,0n),centerY:infNum(0n,0n)},magnificationFactor:infNum(12000n,0n),privContext:{}},{name:"Trapped-Knight",pageTitle:"Trapped Knight",calcFrom:"sequence",desc:"On a chessboard, where the squares are numbered in a spiral, "+"find the squares a knight can jump to in sequence where the "+"smallest-numbered square must always be taken.  Previously-"+"visited squares cannot be returned to again.  After more than "+"2,000 jumps the knight has no valid squares to jump to, so the "+"sequence ends.<br/><br/>"+"Credit to The Online Encyclopedia of Integer Sequences:<br/>"+"<a target='_blank' href='https://oeis.org/A316667'>https://oeis.org/A316667</a><br/>"+"and to Numberphile:<br/>"+"<a target='_blank' href='https://www.youtube.com/watch?v=RGQe8waGJ4w'>https://www.youtube.com/watch?v=RGQe8waGJ4w</a>",gradientType:"pct",computePointsAndLength:function(privContext){var resultPoints=[];var resultLength=0;privContext.visitedSquares={};const params=historyParams;var nextPoint=getPoint(0,0);if(!privContext.isNumberedSquare(privContext,nextPoint)){let testPoint=nextPoint;privContext.trackNumberedSquare(privContext,0,nextPoint);let testDirection=0;let direction=90;for(let i=1;i<3562;i+=1){testDirection=privContext.changeDirection(direction);testPoint=privContext.computeNextPoint(testDirection,1,nextPoint.x,nextPoint.y);if(!privContext.isNumberedSquare(privContext,testPoint)){direction=testDirection;nextPoint=testPoint}else{nextPoint=privContext.computeNextPoint(direction,1,nextPoint.x,nextPoint.y)}privContext.trackNumberedSquare(privContext,i,nextPoint)}}var lastPoint=getPoint(0,0);resultPoints.push(lastPoint);privContext.visitSquare(privContext,0,lastPoint);var reachable=[];var lowestReachableN=-1;var lowestReachableP=null;for(let i=0;i<params.n;i+=1){reachable=privContext.reachableSquares(lastPoint);for(let j=0;j<reachable.length;j++){if(lowestReachableN==-1||privContext.getSquareNumber(privContext,reachable[j])<lowestReachableN){if(!privContext.isVisited(privContext,reachable[j])){lowestReachableP=reachable[j];lowestReachableN=privContext.getSquareNumber(privContext,lowestReachableP)}}}if(lowestReachableN==-1){break}resultLength+=Math.hypot(lowestReachableP.x-lastPoint.x,lowestReachableP.y-lastPoint.y);lastPoint=lowestReachableP;resultPoints.push(getPoint(lastPoint.x,-1*lastPoint.y));privContext.visitSquare(privContext,lowestReachableN,lastPoint);lowestReachableN=-1}return{points:resultPoints,length:resultLength}},forcedDefaults:{n:2016,mag:infNum(1n,0n),centerX:infNum(0n,0n),centerY:infNum(0n,0n)},magnificationFactor:infNum(60n,0n),privContext:{boardPoints:{},visitedSquares:{},trackNumberedSquare:function(privContext,n,point){privContext.boardPoints[point.x+"-"+point.y]=n},isNumberedSquare:function(privContext,point){return point.x+"-"+point.y in privContext.boardPoints},getSquareNumber:function(privContext,point){const id=point.x+"-"+point.y;if(!privContext.boardPoints.hasOwnProperty(id)){console.log("MISSING SQUARE - "+id)}return privContext.boardPoints[id]},visitSquare:function(privContext,n,point){privContext.visitedSquares[point.x+"-"+point.y]=n},isVisited:function(privContext,point){return point.x+"-"+point.y in privContext.visitedSquares},changeDirection:function(dir){return changeDirectionDegrees(dir,-90)},computeNextPoint:function(dir,n,x,y){return computeNextPointDegrees(dir,n,x,y)},reachableSquares:function(s){return[getPoint(s.x+1,s.y-2),getPoint(s.x+2,s.y-1),getPoint(s.x+2,s.y+1),getPoint(s.x+1,s.y+2),getPoint(s.x-1,s.y-2),getPoint(s.x-2,s.y-1),getPoint(s.x-2,s.y+1),getPoint(s.x-1,s.y+2)]},isSquare:function(n){const sqrt=Math.sqrt(n);return sqrt==Math.trunc(sqrt)}}}];