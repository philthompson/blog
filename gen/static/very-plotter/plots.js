// as of 2021-11-09, minify with https://codebeautify.org/minify-js
if("function"==typeof importScripts){let e=null;appVersion||(e=function(){let e=new URLSearchParams(self.location.search);return e.has("v")?e.get("v"):"unk"}()),importScripts("infnum.js?v="+(appVersion||e)),importScripts("floatexp.js?v="+(appVersion||e))}const floatMath={name:"float",zero:0,one:1,two:2,four:4,mul:function(e,t){return e*t},div:function(e,t,n=0){return e/t},add:function(e,t){return e+t},sub:function(e,t){return e-t},complexMul:function(e,t){return{x:e.x*t.x-e.y*t.y,y:e.x*t.y+e.y*t.x}},complexRealMul:function(e,t){return{x:e.x*t,y:e.y*t}},complexAdd:function(e,t){return{x:e.x+t.x,y:e.y+t.y}},complexRealAdd:function(e,t){return{x:e.x+t,y:e.y}},complexAbsSquared:function(e){return e.x*e.x+e.y*e.y},complexAbs:function(e){return Math.hypot(e.x,e.y)},gt:function(e,t){return e>t},lt:function(e,t){return e<t},createFromInfNum:function(e){return parseFloat(infNumExpString(e))},createFromNumber:function(e){return e},createFromExpString:function(e){return parseFloat(e)},toExpString:function(e){return e.toExponential()},truncateToSigDig:function(e,t=0){return e}},floatExpMath={name:"floatexp",zero:createFloatExpFromNumber(0),one:createFloatExpFromNumber(1),two:createFloatExpFromNumber(2),four:createFloatExpFromNumber(4),mul:function(e,t){return floatExpMul(e,t)},div:function(e,t,n=0){return floatExpDiv(e,t)},add:function(e,t){return floatExpAdd(e,t)},sub:function(e,t){return floatExpSub(e,t)},complexMul:function(e,t){return{x:floatExpSub(floatExpMul(e.x,t.x),floatExpMul(e.y,t.y)),y:floatExpAdd(floatExpMul(e.x,t.y),floatExpMul(e.y,t.x))}},complexRealMul:function(e,t){return{x:floatExpMul(e.x,t),y:floatExpMul(e.y,t)}},complexAdd:function(e,t){return{x:floatExpAdd(e.x,t.x),y:floatExpAdd(e.y,t.y)}},complexRealAdd:function(e,t){return{x:floatExpAdd(e.x,t),y:structuredClone(e.y)}},complexAbsSquared:function(e){return floatExpAdd(floatExpMul(e.x,e.x),floatExpMul(e.y,e.y))},complexAbs:function(e){return floatExpSqrt(floatExpAdd(floatExpMul(e.x,e.x),floatExpMul(e.y,e.y)))},gt:function(e,t){return floatExpGt(e,t)},lt:function(e,t){return floatExpLt(e,t)},createFromInfNum:function(e){return createFloatExpFromInfNum(e)},createFromNumber:function(e){return createFloatExpFromNumber(e)},createFromExpString:function(e){return createFloatExpFromString(e)},toExpString:function(e){return floatExpToString(e)},truncateToSigDig:function(e,t=0){return structuredClone(e)}},infNumMath={name:"arbprecis",zero:infNum(0n,0n),one:infNum(1n,0n),two:infNum(2n,0n),four:infNum(4n,0n),mul:function(e,t){return infNumMul(e,t)},div:function(e,t,n=0){return infNumDiv(e,t,n)},add:function(e,t){return infNumAdd(e,t)},sub:function(e,t){return infNumSub(e,t)},complexMul:function(e,t){return{x:infNumSub(infNumMul(e.x,t.x),infNumMul(e.y,t.y)),y:infNumAdd(infNumMul(e.x,t.y),infNumMul(e.y,t.x))}},complexRealMul:function(e,t){return{x:infNumMul(e.x,t),y:infNumMul(e.y,t)}},complexAdd:function(e,t){return{x:infNumAdd(e.x,t.x),y:infNumAdd(e.y,t.y)}},complexRealAdd:function(e,t){return{x:infNumAdd(e.x,t),y:structuredClone(e.y)}},complexAbsSquared:function(e){return infNumAdd(infNumMul(e.x,e.x),infNumMul(e.y,e.y))},complexAbs:function(e){return infNumRoughSqrt(infNumAdd(infNumMul(e.x,e.x),infNumMul(e.y,e.y)))},gt:function(e,t){return infNumGt(e,t)},lt:function(e,t){return infNumLt(e,t)},createFromInfNum:function(e){return structuredClone(e)},createFromNumber:function(e){return createInfNum(e.toString())},createFromExpString:function(e){return createInfNum(e)},toExpString:function(e){return infNumExpString(e)},truncateToSigDig:function(e,t=0){return infNumTruncateToLen(e,t)}},windowCalcBackgroundColor=-1,windowCalcIgnorePointColor=-2,plots=[{name:"Mandelbrot-set",pageTitle:"Mandelbrot set",calcFrom:"window",desc:"The Mandelbrot set is the set of complex numbers, that when repeatedly plugged into the following simple function, does <i>not</i> run away to infinity.  The function is z<sub>n+1</sub> = z<sub>n</sub><sup>2</sup> + c.<br/>For each plotted point <code>c</code>, we repeat the above function many times.<br/>If the value jumps off toward infinity after say 10 iterations, we display a color at the pixel for point <code>c</code>.<br/>If the value doesn't go off toward infinity until say 50 iterations, we pick a quite different color for that point.<br/>If, after our alloted number of iterations has been computed, the value still hasn't gone off to infinity, we color that pixel the backgrond color (defaulting to black).<br/><br/>Wikipedia has a terrific <a target='_blank' href='https://en.wikipedia.org/wiki/Mandelbrot_set'>article with pictures</a>.<br/><br/>My favorite explanation I've found so far is <a target='_blank' href='https://www.youtube.com/watch?v=FFftmWSzgmk'>this Numberphile video on YouTube</a>.<br/><br/><b>Tips for using this Mandelbrot set viewer</b>:<br/>- When not zoomed in very far, keep the <code>n</code> (iterations) parameter low for faster calculation (use N and M keys to decrease/increase the <code>n</code> value).<br/>- To see more detail when zoomed in, increase the <code>n</code> (iterations) parameter with the M key.  Calculations will be slower.",computeBoundPointColor:function(e,t,n,r,o){const i=n.includes("arbprecis")?infNumMath:n.includes("floatexp")?floatExpMath:floatMath,a=e;if("basic-float"==n){let e=parseFloat(infNumExpStringTruncToLen(r,15)),t=parseFloat(infNumExpStringTruncToLen(o,15)),n=0,i=0,u=0,l=0,s=0,c=0;for(;c<a&&(u=n*n,l=i*i,!(u+l>4));)s=e+(u-l),i=t+2*n*i,n=s,c++;return c==a?-1:c/a}const u=i.createFromInfNum(r),l=i.createFromInfNum(o);var s=structuredClone(i.zero),c=structuredClone(i.zero),f=structuredClone(i.zero),m=structuredClone(i.zero),p=structuredClone(i.zero),d=0;try{for(;d<a&&(f=i.mul(s,s),m=i.mul(c,c),!i.gt(i.add(f,m),i.four));)p=i.add(u,i.sub(f,m)),c=i.add(l,i.mul(i.two,i.mul(s,c))),s=p,s=i.truncateToSigDig(s,t),c=i.truncateToSigDig(c,t),d++;return d==a?-1:d/a}catch(e){return console.log("ERROR CAUGHT when processing point (x, y, iter, maxIter): ["+i.toExpString(r)+", "+i.toExpString(o)+", "+d+", "+a+"]:"),console.log(e.name+": "+e.message+":\n"+e.stack.split("\n").slice(0,5).join("\n")),-2}},computeReferenceOrbit:function(e,t,n,r,o,i){const a=n.includes("arbprecis")?infNumMath:n.includes("floatexp")?floatExpMath:floatMath,u="floatexp"==a.name,l=e,s=infNum(2n,0n),c=(infNum(4n,0n),infNum(16n,0n));null===i&&(i={ix:infNum(0n,0n),iy:infNum(0n,0n),iter:0,orbit:[],status:"",done:!1});var f=infNum(0n,0n),m=infNum(0n,0n),p=infNum(0n,0n),d=0;try{for(;i.iter<l&&(f=infNumMul(i.ix,i.ix),m=infNumMul(i.iy,i.iy),!infNumGt(infNumAdd(f,m),c));)if(i.orbit.push({x:a.createFromInfNum(i.ix),y:a.createFromInfNum(i.iy),xfxp:u?null:floatExpMath.createFromInfNum(i.ix),yfxp:u?null:floatExpMath.createFromInfNum(i.iy)}),p=infNumAdd(r,infNumSub(f,m)),i.iy=infNumAdd(o,infNumMul(s,infNumMul(i.ix,i.iy))),i.ix=copyInfNum(p),i.ix=infNumTruncateToLen(i.ix,t),i.iy=infNumTruncateToLen(i.iy,t),i.iter++,++d>=5e3)return d=0,i.status="computed "+Math.round(1e4*i.iter/l)/100+"% of reference orbit",console.log(i.status),i;return i.done=!0,i}catch(e){return console.log("ERROR CAUGHT when computing reference orbit at point (x, y, iter, maxIter): ["+infNumToString(r)+", "+infNumToString(o)+", "+iter+", "+l+"]:"),console.log(e.name+": "+e.message+":\n"+e.stack.split("\n").slice(0,5).join("\n")),i.done=!0,i}},computeSaCoefficients:function(e,t,n,r,o,i,a){const u=floatExpMath,l="floatexp"==(t.includes("arbprecis")?infNumMath:t.includes("floatexp")?floatExpMath:floatMath).name;if(null===a){let n=3,r=3;try{let e=t.split("-").find((e=>e.startsWith("sapx"))).substring(4).split(".");n=Math.max(3,Math.min(128,parseInt(BigInt(e[0]).toString()))),r=Math.max(1,Math.min(7,parseInt(BigInt(e[1]).toString())))}catch{}let o=[],l=i.top,s=infNumDiv(infNumSub(i.right,i.left),infNum(BigInt(r),0n),e),c=infNumDiv(infNumSub(i.top,i.bottom),infNum(BigInt(r),0n),e);for(let e=0;e<=r;e++){let e=i.left;for(let t=0;t<=r;t++)o.push({x:copyInfNum(e),y:copyInfNum(l)}),e=infNumAdd(e,s);l=infNumAdd(l,c)}let f=new Array(n).fill({x:u.zero,y:u.zero});f[0]={x:u.one,y:u.zero},a={nTerms:n,termShrinkCutoff:u.createFromNumber(1e6),testPoints:o,terms:f,itersToSkip:-1,refOrbitIter:0,saCoefficients:{itersToSkip:0,coefficients:[]},status:"",done:!1}}if(a.nTerms<=0)return console.log("series approximation has 0 or fewer terms in the algorithm name ["+t+"], so NOT doing SA"),a.done=!0,a;let s=null;const c=new Array(a.nTerms);let f=a.refOrbitIter,m=0;for(;f<o.length-2;f++){s=l?u.complexRealMul(o[f],u.two):u.complexRealMul({x:o[f].xfxp,y:o[f].yfxp},u.two);for(let e=0;e<a.nTerms;e++)if(0===e)c[e]=u.complexRealAdd(u.complexMul(s,a.terms[e]),u.one);else if(e%2==0){c[e]=u.complexMul(s,a.terms[e]);for(let t=0,n=e-1;t<n;t++,n--)c[e]=u.complexAdd(c[e],u.complexRealMul(u.complexMul(a.terms[t],a.terms[n]),u.two))}else{c[e]=u.complexMul(s,a.terms[e]);for(let t=0,n=e-1;t<=n;t++,n--)c[e]=t===n?u.complexAdd(c[e],u.complexMul(a.terms[t],a.terms[n])):u.complexAdd(c[e],u.complexRealMul(u.complexMul(a.terms[t],a.terms[n]),u.two))}let e=0;for(let t=0;t<a.testPoints.length;t++){let o={x:u.createFromInfNum(infNumSub(a.testPoints[t].x,n)),y:u.createFromInfNum(infNumSub(a.testPoints[t].y,r))},i=!1;for(let e=1;e<a.nTerms;e++){let t=structuredClone(o),n=null,r=null;for(let r=0;r<e;r++){let e=u.complexAbsSquared(u.complexMul(t,c[r]));(null===n||u.lt(e,n))&&(n=structuredClone(e)),t=u.complexMul(t,o)}for(let n=e;n<a.nTerms;n++){let e=u.complexAbsSquared(u.complexMul(t,c[n]));(null===r||u.gt(e,r))&&(r=structuredClone(e)),t=u.complexMul(t,o)}if(0n===r.v){i=!0;break}let l=u.div(n,r);if(u.gt(l,a.termShrinkCutoff)){i=!0;break}}if(!i){console.log("SA test point ["+t+"] is not valid at iteraition ["+f+"]");break}e++}if(e<a.testPoints.length){a.itersToSkip=f,a.done=!0,console.log("SA stopping with ["+f+"] valid iterations");break}for(let e=0;e<a.nTerms;e++)a.terms[e]=c[e];if(m++,m>=5e3)return a.status="can skip "+Math.round(1e4*f/o.length)/100+"% of reference orbit",console.log("all test points are valid for skipping ["+f.toLocaleString()+"] iterations"),a.refOrbitIter=f+1,a}return a.done=!0,a.itersToSkip<0?(console.log("able to skip ALL ["+o.length+"] iterations of the reference orbit with ["+a.nTerms+"]-term SA... hmm... perhaps N is set too low"),a.saCoefficients={itersToSkip:f,coefficients:a.terms}):(console.log("able to skip ["+a.itersToSkip+"] iterations with ["+a.nTerms+"]-term SA"),a.saCoefficients={itersToSkip:a.itersToSkip,coefficients:a.terms}),a},computeBlaTables:function(e,t,n){const r=e.includes("arbprecis")?infNumMath:e.includes("floatexp")?floatExpMath:floatMath;if(null===n){const e=r.createFromNumber(2**-53);n={epsilonSquared:r.mul(e,e),blaTables:{coefTable:new Map,epsilonRefAbsTable:new Map},a:{x:r.one,y:r.zero},b:{x:r.zero,y:r.zero},blaCoeffIter:0,epsRefOrbitIter:0,status:"",done:!1}}let o=n.a,i=n.b,a=null,u=0,l=t.length-2,s=n.blaCoeffIter;for(;s<l;s++)if(a=r.complexRealMul(t[s],r.two),o=r.complexMul(a,o),i=r.complexAdd(r.complexMul(a,i),{x:r.one,y:r.zero}),n.blaTables.coefTable.set(s,{a:o,aAbs:r.complexAbs(o),b:i,bAbs:r.complexAbs(i)}),u++,u>=1e4)return n.blaCoeffIter=s+1,n.status="computed "+Math.round(1e4*s/l)/100+"% of BLA coefficients",console.log(n.status),n;n.blaCoeffIter=s,u=0,l=t.length;let c=n.epsRefOrbitIter;for(;c<l;c++)if(n.blaTables.epsilonRefAbsTable.set(c,r.complexAbs(t[c])),u++,u>=1e4)return n.epsRefOrbitIter=c+1,n.status="computed "+Math.round(1e4*c/l)/100+"% of BLA epsilon criteria",console.log(n.status),n;return n.epsRefOrbitIter=c,n.done=!0,n},computeBoundPointColorPerturbOrBla:function(e,t,n,r,o,i,a,u,l,s){const c=o.includes("arbprecis")?infNumMath:o.includes("floatexp")?floatExpMath:floatMath,f=o.includes("bla-"),m=o.includes("sapx"),p=e,d=infNumSub(n,i),x=infNumSub(r,a);let g={x:c.createFromInfNum(d),y:c.createFromInfNum(x)},h={x:floatExpMath.createFromInfNum(d),y:floatExpMath.createFromInfNum(x)};const b=c.complexAbs(g);let N=0;const y=u.length-2;let M=0,S={x:c.zero,y:c.zero},v=null,P=null,A=null;if(m&&s.itersToSkip>0){let e={x:floatExpMath.zero,y:floatExpMath.zero},t=structuredClone(h);for(let n=0;n<s.coefficients.length;n++)e=floatExpMath.complexAdd(e,floatExpMath.complexMul(s.coefficients[n],t)),t=floatExpMath.complexMul(t,h);N+=s.itersToSkip,M+=s.itersToSkip,S="floatexp"==c.name?e:{x:c.createFromExpString(floatExpMath.toExpString(e.x)),y:c.createFromExpString(floatExpMath.toExpString(e.y))}}let w=0,I=0;try{for(;N<p;){if(S=c.complexAdd(c.complexAdd(c.complexMul(c.complexRealMul(u[M],c.two),S),c.complexMul(S,S)),g),N++,M++,v=c.complexAdd(u[M],S),P=c.complexAbsSquared(v),c.gt(P,c.four)){N--;break}if(A=c.complexAbsSquared(S),c.lt(P,A)||M==y)S=v,M=0;else if(f){const e=c.createFromNumber(16**-243);let t=null;if(M/y<.95){let n=null,r=null;for(let o=1;o<y-M-15&&(n=l.coefTable.get(o),r=l.epsilonRefAbsTable.get(M+o),c.lt(c.complexAbs(S),c.mul(e,c.div(c.sub(r,c.mul(n.bAbs,b)),c.add(n.aAbs,c.one)))));o++)t=o}null!==t&&(S=c.complexAdd(c.complexMul(l.coefTable.get(t).a,S),c.complexMul(l.coefTable.get(t).b,g)),N+=t,M+=t,w+=t,I++)}}return N==p?{colorpct:-1,blaItersSkipped:w,blaSkips:I}:{colorpct:N/p,blaItersSkipped:w,blaSkips:I}}catch(e){return console.log("ERROR CAUGHT when calculating ["+o+"] pixel color",{x:infNumToString(n),y:infNumToString(r),iter:N,maxIter:p,refIter:M,maxRefIter:y}),console.log(e.name+": "+e.message+":\n"+e.stack.split("\n").slice(0,5).join("\n")),{colorpct:-2,blaItersSkipped:w,blaSkips:I}}},forcedDefaults:{n:40,mag:infNum(1n,0n),centerX:createInfNum("-0.65"),centerY:infNum(0n,0n)},magnificationFactor:infNum(3n,0n),privContext:{usesImaginaryCoordinates:!0,adjustPrecision:function(e,t){const n=infNumTruncateToLen(e,8),r={roughScale:infNumExpString(n),precision:12,algorithm:"basic-float"};return infNumGe(n,createInfNum("1e800"))?r.algorithm="perturb-sapx32-floatexp":infNumGe(n,createInfNum("1e500"))?r.algorithm="perturb-sapx16-floatexp":infNumGe(n,createInfNum("1e304"))?r.algorithm="perturb-sapx8-floatexp":infNumGe(n,createInfNum("1e200"))?r.algorithm="perturb-sapx6-float":infNumGe(n,createInfNum("1e100"))?r.algorithm="perturb-sapx4-float":infNumGe(n,createInfNum("3e13"))&&(r.algorithm="perturb-float"),infNumLt(n,createInfNum("1e3"))||infNumLt(n,createInfNum("2e6"))?r.precision=12:infNumLt(n,createInfNum("3e13"))?r.precision=20:infNumLt(n,createInfNum("1e40"))?r.precision=Math.floor(1.7*infNumMagnitude(n)):infNumLt(n,createInfNum("1e60"))?r.precision=Math.floor(1.5*infNumMagnitude(n)):infNumLt(n,createInfNum("1e100"))?r.precision=Math.floor(1.4*infNumMagnitude(n)):infNumLt(n,createInfNum("1e150"))?r.precision=Math.floor(1.25*infNumMagnitude(n)):infNumLt(n,createInfNum("1e200"))?r.precision=Math.floor(1.1*infNumMagnitude(n)):r.precision=Math.floor(1.01*infNumMagnitude(n)),t||(infNumGe(n,createInfNum("1e304"))?r.algorithm="perturb-floatexp":infNumGe(n,createInfNum("3e13"))?r.algorithm="perturb-float":r.algorithm="basic-float"),console.log("default mandelbrot settings for scale:",r),r},listAlgorithms:function(){return[{algorithm:"auto",name:"automatic"},{algorithm:"basic-float",name:"basic escape time, floating point"},{algorithm:"basic-floatexp",name:"basic escape time, floatexp"},{algorithm:"perturb-float",name:"perturbation theory, floating point"},{algorithm:"perturb-floatexp",name:"perturbation theory, floatexp"},{algorithm:"perturb-sapx4-float",name:"perturb. w/series approx., floating point"},{algorithm:"perturb-sapx8-floatexp",name:"perturb. w/series approx., floatexp"},{algorithm:"perturb-sapx6.4-floatexp-sigdig64",name:"custom"}]},minScale:createInfNum("20")}},{name:"Primes-1-Step-90-turn",pageTitle:"Primes",calcFrom:"sequence",desc:"Move 1 step forward per integer, but for primes, turn 90 degrees clockwise before moving.",computePointsAndLength:function(e){var t=[],n=0;historyParams.n>5e6&&(historyParams.n=5e6);const r=historyParams;t.push(getPoint(0,0));var o=getPoint(0,0);e.direction=0;for(var i=1;i<r.n;i++)isPrime(i)&&(o.v={prime:i.toLocaleString()},t.push(o),e.direction=e.changeDirection(e.direction)),o=e.computeNextPoint(e.direction,i,o.x,o.y,{last:(i+1).toLocaleString()}),n+=1;return isPrime(parseInt(o.v.last))&&(o.v={prime:o.v.last}),t.push(o),{points:t,length:n}},forcedDefaults:{n:6e4,mag:infNum(1n,0n),centerX:createInfNum("-240"),centerY:createInfNum("288")},magnificationFactor:infNum(850n,0n),privContext:{direction:0,changeDirection:function(e){return changeDirectionDegrees(e,90)},computeNextPoint:function(e,t,n,r,o){return computeNextPointDegrees(e,1,n,r,o)}}},{name:"Primes-1-Step-45-turn",pageTitle:"Primes",calcFrom:"sequence",desc:"Move 1 step forward per integer, but for primes, turn 45 degrees clockwise before moving.  When moving diagonally, we move 1 step on both the x and y axes, so we're actually moving ~1.414 steps diagonally.",computePointsAndLength:function(e){var t=[],n=0;historyParams.n>5e6&&(historyParams.n=5e6);const r=historyParams;t.push(getPoint(0,0));var o=getPoint(0,0);e.direction=315;for(var i=1;i<r.n;i++)isPrime(i)&&(o.v={prime:i.toLocaleString()},t.push(o),e.direction=e.changeDirection(e.direction)),o=e.computeNextPoint(e.direction,i,o.x,o.y,{last:(i+1).toLocaleString()}),n+=1;return isPrime(parseInt(o.v.last))&&(o.v={prime:o.v.last}),t.push(o),{points:t,length:n}},forcedDefaults:{n:6e4,mag:infNum(1n,0n),centerX:infNum(0n,0n),centerY:infNum(415n,0n)},magnificationFactor:infNum(1600n,0n),privContext:{direction:0,changeDirection:function(e){return changeDirectionDegrees(e,45)},computeNextPoint:function(e,t,n,r,o){return computeNextPointDegrees(e,1,n,r,o)}}},{name:"Squares-1-Step-90-turn",pageTitle:"Squares",calcFrom:"sequence",desc:"Move 1 step forward per integer, but for perfect squares, turn 90 degrees clockwise before moving.",computePointsAndLength:function(e){var t=[],n=0;historyParams.n>1e6&&(historyParams.n=1e6);const r=historyParams;var o=getPoint(0,0);e.direction=270;for(var i=1;i<r.n;i+=1)e.isSquare(i)&&(t.push(o),e.direction=e.changeDirection(e.direction)),o=e.computeNextPoint(e.direction,i,o.x,o.y,{square:(i+1).toLocaleString()}),n+=1;return e.isSquare(parseInt(o.v.square))||(o.v={last:o.v.square}),t.push(o),{points:t,length:n}},forcedDefaults:{n:5e3,mag:infNum(1n,0n),centerX:infNum(0n,0n),centerY:infNum(0n,0n)},magnificationFactor:infNum(175n,0n),privContext:{direction:0,changeDirection:function(e){return changeDirectionDegrees(e,90)},computeNextPoint:function(e,t,n,r,o){return computeNextPointDegrees(e,1,n,r,o)},isSquare:function(e){const t=Math.sqrt(e);return t==Math.trunc(t)}}},{name:"Squares-1-Step-45-turn",pageTitle:"Squares",calcFrom:"sequence",desc:"Move 1 step forward per integer, but for perfect squares, turn 45 degrees clockwise before moving.  When moving diagonally, we move 1 step on both the x and y axes, so we're actually moving ~1.414 steps diagonally.",computePointsAndLength:function(e){var t=[],n=0;const r=Math.sqrt(2);historyParams.n>1e6&&(historyParams.n=1e6);const o=historyParams;var i=getPoint(0,0);e.direction=270;for(var a=1;a<o.n;a+=1)e.isSquare(a)&&(t.push(i),e.direction=e.changeDirection(e.direction)),i=e.computeNextPoint(e.direction,a,i.x,i.y,{square:(a+1).toLocaleString()}),n+=e.direction%90==0?1:r;return e.isSquare(parseInt(i.v.square))||(i.v={last:i.v.square}),t.push(i),{points:t,length:n}},forcedDefaults:{n:5e3,mag:infNum(1n,0n),centerX:infNum(0n,0n),centerY:infNum(0n,0n)},magnificationFactor:infNum(500n,0n),privContext:{direction:0,changeDirection:function(e){return changeDirectionDegrees(e,45)},computeNextPoint:function(e,t,n,r,o){return computeNextPointDegrees(e,1,n,r,o)},isSquare:function(e){const t=Math.sqrt(e);return t==Math.trunc(t)}}},{name:"Primes-X-Y-neg-mod-3",pageTitle:"Primes",calcFrom:"sequence",desc:"Where each plotted point <code>(x,y)</code> consists of the primes, in order.  Those points are (2,3), (5,7), (11,13), and so on.<br/><br/>Then we take the sum of the digits of both the <code>x</code> and <code>y</code> of each point.<br/>If that sum, mod 3, is 1, the <code>x</code> is negated.<br/>If that sum, mod 3, is 2, the <code>y</code> is negated.<br/><br/>After applying the negation rule, the first three plotted points become:<br/><code>(2,3)&nbsp;&nbsp;→ sum digits = 5&nbsp;&nbsp;mod 3 = 2 → -y → (2,-3)</code><br/><code>(5,7)&nbsp;&nbsp;→ sum digits = 12 mod 3 = 0 →&nbsp;&nbsp;&nbsp;&nbsp;→ (5,7)</code><br/><code>(11,13)→ sum digits = 6&nbsp;&nbsp;mod 3 = 0 →&nbsp;&nbsp;&nbsp;&nbsp;→ (11,13)</code>",computePointsAndLength:function(e){var t=[],n=0;historyParams.n>1e6&&(historyParams.n=1e6);const r=historyParams;var o=-1,i=getPoint(0,0);t.push(i);for(var a=1;a<r.n;a+=1)if(isPrime(a))if(-1==o)o=a;else{var u=a;const e=(o.toString()+u.toString()).split("");for(var l=0,s=0;s<e.length;s++)l+=e[s];const r=l%3;1==r?o*=-1:2==r&&(u*=-1);const c=getPoint(parseFloat(o),parseFloat(u),{prime:a.toLocaleString()});n+=Math.hypot(c.x-i.x,c.y-i.y),t.push(c),o=-1,i=c}return{points:t,length:n}},forcedDefaults:{n:5e3,mag:infNum(1n,0n),centerX:infNum(0n,0n),centerY:infNum(0n,0n)},magnificationFactor:infNum(12000n,0n),privContext:{}},{name:"Trapped-Knight",pageTitle:"Trapped Knight",calcFrom:"sequence",desc:"On a chessboard, where the squares are numbered in a spiral, find the squares a knight can jump to in sequence where the smallest-numbered square must always be taken.  Previously-visited squares cannot be returned to again.  After more than 2,000 jumps the knight has no valid squares to jump to, so the sequence ends.<br/><br/>Credit to The Online Encyclopedia of Integer Sequences:<br/><a target='_blank' href='https://oeis.org/A316667'>https://oeis.org/A316667</a><br/>and to Numberphile:<br/><a target='_blank' href='https://www.youtube.com/watch?v=RGQe8waGJ4w'>https://www.youtube.com/watch?v=RGQe8waGJ4w</a>",computePointsAndLength:function(e){var t=[],n=0;e.visitedSquares={};const r=historyParams;var o=getPoint(0,0);if(!e.isNumberedSquare(e,o)){let t=o;e.trackNumberedSquare(e,0,o);let n=0,r=90;for(let i=1;i<3562;i+=1)n=e.changeDirection(r),t=e.computeNextPoint(n,1,o.x,o.y),e.isNumberedSquare(e,t)?o=e.computeNextPoint(r,1,o.x,o.y):(r=n,o=t),e.trackNumberedSquare(e,i,o)}var i=getPoint(0,0);t.push(i),e.visitSquare(e,0,i);var a=[],u=-1,l=null;for(let o=0;o<r.n;o+=1){a=e.reachableSquares(i);for(let t=0;t<a.length;t++)(-1==u||e.getSquareNumber(e,a[t])<u)&&(e.isVisited(e,a[t])||(l=a[t],u=e.getSquareNumber(e,l)));if(-1==u)break;n+=Math.hypot(l.x-i.x,l.y-i.y),i=l,t.push(getPoint(i.x,-1*i.y)),e.visitSquare(e,u,i),u=-1}return{points:t,length:n}},forcedDefaults:{n:2016,mag:infNum(1n,0n),centerX:infNum(0n,0n),centerY:infNum(0n,0n)},magnificationFactor:infNum(60n,0n),privContext:{boardPoints:{},visitedSquares:{},trackNumberedSquare:function(e,t,n){e.boardPoints[n.x+"-"+n.y]=t},isNumberedSquare:function(e,t){return t.x+"-"+t.y in e.boardPoints},getSquareNumber:function(e,t){const n=t.x+"-"+t.y;return!n in e.boardPoints&&console.log("MISSING SQUARE - "+n),e.boardPoints[n]},visitSquare:function(e,t,n){e.visitedSquares[n.x+"-"+n.y]=t},isVisited:function(e,t){return t.x+"-"+t.y in e.visitedSquares},changeDirection:function(e){return changeDirectionDegrees(e,-90)},computeNextPoint:function(e,t,n,r){return computeNextPointDegrees(e,t,n,r)},reachableSquares:function(e){return[getPoint(e.x+1,e.y-2),getPoint(e.x+2,e.y-1),getPoint(e.x+2,e.y+1),getPoint(e.x+1,e.y+2),getPoint(e.x-1,e.y-2),getPoint(e.x-2,e.y-1),getPoint(e.x-2,e.y+1),getPoint(e.x-1,e.y+2)]},isSquare:function(e){const t=Math.sqrt(e);return t==Math.trunc(t)}}}];