// as of 2021-11-09, minify with https://codebeautify.org/minify-js
if("function"==typeof importScripts){let e=null;appVersion||(e=function(){let e=new URLSearchParams(self.location.search);return e.has("v")?e.get("v"):"unk"}()),importScripts("infnum.js?v="+(appVersion||e)),importScripts("floatexp.js?v="+(appVersion||e))}function complexFloatMul(e,t){return{x:e.x*t.x-e.y*t.y,y:e.x*t.y+e.y*t.x}}function complexFloatRealMul(e,t){return{x:e.x*t,y:e.y*t}}function complexFloatAdd(e,t){return{x:e.x+t.x,y:e.y+t.y}}function complexFloatExpMul(e,t){return{x:floatExpSub(floatExpMul(e.x,t.x),floatExpMul(e.y,t.y)),y:floatExpAdd(floatExpMul(e.x,t.y),floatExpMul(e.y,t.x))}}function complexFloatExpRealMul(e,t){return{x:floatExpMul(e.x,t),y:floatExpMul(e.y,t)}}function complexFloatExpAdd(e,t){return{x:floatExpAdd(e.x,t.x),y:floatExpAdd(e.y,t.y)}}function complexFloatExpAbs(e){return floatExpAdd(floatExpMul(e.x,e.x),floatExpMul(e.y,e.y))}const windowCalcIgnorePointColor=-2,plots=[{name:"Mandelbrot-set",pageTitle:"Mandelbrot set",calcFrom:"window",desc:"The Mandelbrot set is the set of complex numbers, that when repeatedly plugged into the following simple function, does <i>not</i> run away to infinity.  The function is z<sub>n+1</sub> = z<sub>n</sub><sup>2</sup> + c.<br/>For each plotted point <code>c</code>, we repeat the above function many times.<br/>If the value jumps off toward infinity after say 10 iterations, we display a color at the pixel for point <code>c</code>.<br/>If the value doesn't go off toward infinity until say 50 iterations, we pick a quite different color for that point.<br/>If, after our alloted number of iterations has been computed, the value still hasn't gone off to infinity, we color that pixel the backgrond color (defaulting to black).<br/><br/>Wikipedia has a terrific <a target='_blank' href='https://en.wikipedia.org/wiki/Mandelbrot_set'>article with pictures</a>.<br/><br/>My favorite explanation I've found so far is <a target='_blank' href='https://www.youtube.com/watch?v=FFftmWSzgmk'>this Numberphile video on YouTube</a>.<br/><br/><b>Tips for using this Mandelbrot set viewer</b>:<br/>- When not zoomed in very far, keep the <code>n</code> (iterations) parameter low for faster calculation (use N and M keys to decrease/increase the <code>n</code> value).<br/>- To see more detail when zoomed in, increase the <code>n</code> (iterations) parameter with the M key.  Calculations will be slower.",computeBoundPointColor:function(e,t,n,o,r){const i=e,a=infNum(4n,0n);if("basic-float"==n){let e=parseFloat(infNumExpStringTruncToLen(o,15)),t=parseFloat(infNumExpStringTruncToLen(r,15)),n=0,a=0,u=0,s=0,c=0,l=0;for(;l<i&&(u=n*n,s=a*a,!(u+s>4));)c=e+(u-s),a=t+2*n*a,n=c,l++;return l==i?-1:l/i}if("basic-arbprecis"!=n)return console.log("unexpected/unknown algorithm ["+n+"]"),-2;const u=infNum(2n,0n);var s=infNum(0n,0n),c=infNum(0n,0n),l=infNum(0n,0n),m=infNum(0n,0n),p=infNum(0n,0n),f=0;try{for(;f<i&&(l=infNumMul(s,s),m=infNumMul(c,c),!infNumGt(infNumAdd(l,m),a));)p=infNumAdd(o,infNumSub(l,m)),c=infNumAdd(r,infNumMul(u,infNumMul(s,c))),s=p,s=infNumTruncateToLen(s,t),c=infNumTruncateToLen(c,t),f++;return f==i?-1:f/i}catch(e){return console.log("ERROR CAUGHT when processing point (x, y, iter, maxIter): ["+infNumToString(o)+", "+infNumToString(r)+", "+f+", "+i+"]:"),console.log(e.name+": "+e.message+":\n"+e.stack.split("\n").slice(0,5).join("\n")),-2}},computeReferenceOrbit:function(e,t,n,o,r){let i=!1;n.includes("floatexp")?i=!0:n.includes("float")||console.log("unexpected/unknown reference orbit algorithm ["+n+"], falling back to float");let a=[];const u=e,s=infNum(2n,0n),c=infNum(4n,0n);var l=infNum(0n,0n),m=infNum(0n,0n),p=infNum(0n,0n),f=infNum(0n,0n),d=infNum(0n,0n),g=0;try{for(;g<u&&(p=infNumMul(l,l),f=infNumMul(m,m),!infNumGt(infNumAdd(p,f),c));)i?a.push({x:createFloatExpFromInfNum(l),y:createFloatExpFromInfNum(m)}):a.push({x:parseFloat(infNumExpString(l)),y:parseFloat(infNumExpString(m))}),d=infNumAdd(o,infNumSub(p,f)),m=infNumAdd(r,infNumMul(s,infNumMul(l,m))),l=copyInfNum(d),l=infNumTruncateToLen(l,t),m=infNumTruncateToLen(m,t),g++;return a}catch(e){return console.log("ERROR CAUGHT when computing reference orbit at point (x, y, iter, maxIter): ["+infNumToString(o)+", "+infNumToString(r)+", "+g+", "+u+"]:"),console.log(e.name+": "+e.message+":\n"+e.stack.split("\n").slice(0,5).join("\n")),a}},computeBoundPointColorPerturbFloat:function(e,t,n,o,r,i,a){const u=e,s=infNumSub(n,r),c=infNumSub(o,i);let l={x:parseFloat(infNumExpString(s)),y:parseFloat(infNumExpString(c))},m=0;const p=a.length-2;let f=0,d={x:0,y:0},g=null,h=null,x=null;try{for(;m<u&&(d=complexFloatAdd(complexFloatAdd(complexFloatMul(complexFloatRealMul(a[f],2),d),complexFloatMul(d,d)),l),f++,g=complexFloatAdd(a[f],d),h=g.x*g.x+g.y*g.y,!(h>4));)x=d.x*d.x+d.y*d.y,(h<x||f==p)&&(d=g,f=0),m++;return m==u?-1:m/u}catch(e){return console.log("ERROR CAUGHT when processing perturb point",{x:infNumToString(n),y:infNumToString(o),iter:m,maxIter:u,refIter:f,maxRefIter:p}),console.log(e.name+": "+e.message+":\n"+e.stack.split("\n").slice(0,5).join("\n")),-2}},computeBoundPointColorPerturbFloatExp:function(e,t,n,o,r,i,a){const u=createFloatExpFromNumber(4),s=createFloatExpFromNumber(2),c=e,l=infNumSub(n,r),m=infNumSub(o,i);let p={x:createFloatExpFromInfNum(l),y:createFloatExpFromInfNum(m)},f=0;const d=a.length-2;let g=0,h={x:createFloatExpFromNumber(0),y:createFloatExpFromNumber(0)},x=null,b=null,N=null;try{for(;f<c&&(h=complexFloatExpAdd(complexFloatExpAdd(complexFloatExpMul(complexFloatExpRealMul(a[g],s),h),complexFloatExpMul(h,h)),p),g++,x=complexFloatExpAdd(a[g],h),b=complexFloatExpAbs(x),!floatExpGt(b,u));)N=complexFloatExpAbs(h),(floatExpLt(b,N)||g==d)&&(h=x,g=0),f++;return f==c?-1:f/c}catch(e){return console.log("ERROR CAUGHT when processing perturb-floatexp point",{x:infNumToString(n),y:infNumToString(o),iter:f,maxIter:c,refIter:g,maxRefIter:d}),console.log(e.name+": "+e.message+":\n"+e.stack.split("\n").slice(0,5).join("\n")),-2}},forcedDefaults:{n:40,scale:infNum(400n,0n),centerX:createInfNum("-0.65"),centerY:infNum(0n,0n)},privContext:{usesImaginaryCoordinates:!0,adjustPrecision:function(e){const t=infNumTruncateToLen(e,8),n={roughScale:infNumExpString(t),precision:12,algorithm:"basic-float"};if(infNumGe(t,createInfNum("1e304"))?n.algorithm="perturb-floatexp":infNumGe(t,createInfNum("3e13"))&&(n.algorithm="perturb-float"),infNumLt(t,createInfNum("1e3")))n.precision=12;else if(infNumLt(t,createInfNum("2e6")))n.precision=12;else if(infNumLt(t,createInfNum("3e13")))n.precision=20;else{n.precision=-1;for(let e=32;e<=304;e+=16)if(infNumLt(t,createInfNum("1e"+e))){n.precision=e;break}n.precision<0&&(n.precision=Math.floor(1.01*infNumMagnitude(t)))}return console.log("mandelbrot settings for scale:",n),n},minScale:createInfNum("20")}},{name:"Primes-1-Step-90-turn",pageTitle:"Primes",calcFrom:"sequence",desc:"Move 1 step forward per integer, but for primes, turn 90 degrees clockwise before moving.",computePointsAndLength:function(e){var t=[],n=0;historyParams.n>5e6&&(historyParams.n=5e6);const o=historyParams;t.push(getPoint(0,0));var r=getPoint(0,0);e.direction=0;for(var i=1;i<o.n;i++)isPrime(i)&&(r.v={prime:i.toLocaleString()},t.push(r),e.direction=e.changeDirection(e.direction)),r=e.computeNextPoint(e.direction,i,r.x,r.y,{last:(i+1).toLocaleString()}),n+=1;return isPrime(parseInt(r.v.last))&&(r.v={prime:r.v.last}),t.push(r),{points:t,length:n}},forcedDefaults:{n:6e4,scale:createInfNum("1.2"),centerX:createInfNum("-240"),centerY:createInfNum("288")},privContext:{direction:0,changeDirection:function(e){return changeDirectionDegrees(e,90)},computeNextPoint:function(e,t,n,o,r){return computeNextPointDegrees(e,1,n,o,r)}}},{name:"Primes-1-Step-45-turn",pageTitle:"Primes",calcFrom:"sequence",desc:"Move 1 step forward per integer, but for primes, turn 45 degrees clockwise before moving.  When moving diagonally, we move 1 step on both the x and y axes, so we're actually moving ~1.414 steps diagonally.",computePointsAndLength:function(e){var t=[],n=0;historyParams.n>5e6&&(historyParams.n=5e6);const o=historyParams;t.push(getPoint(0,0));var r=getPoint(0,0);e.direction=315;for(var i=1;i<o.n;i++)isPrime(i)&&(r.v={prime:i.toLocaleString()},t.push(r),e.direction=e.changeDirection(e.direction)),r=e.computeNextPoint(e.direction,i,r.x,r.y,{last:(i+1).toLocaleString()}),n+=1;return isPrime(parseInt(r.v.last))&&(r.v={prime:r.v.last}),t.push(r),{points:t,length:n}},forcedDefaults:{n:6e4,scale:createInfNum("0.85"),centerX:infNum(0n,0n),centerY:infNum(0n,0n)},privContext:{direction:0,changeDirection:function(e){return changeDirectionDegrees(e,45)},computeNextPoint:function(e,t,n,o,r){return computeNextPointDegrees(e,1,n,o,r)}}},{name:"Squares-1-Step-90-turn",pageTitle:"Squares",calcFrom:"sequence",desc:"Move 1 step forward per integer, but for perfect squares, turn 90 degrees clockwise before moving.",computePointsAndLength:function(e){var t=[],n=0;historyParams.n>1e6&&(historyParams.n=1e6);const o=historyParams;var r=getPoint(0,0);e.direction=270;for(var i=1;i<o.n;i+=1)e.isSquare(i)&&(t.push(r),e.direction=e.changeDirection(e.direction)),r=e.computeNextPoint(e.direction,i,r.x,r.y,{square:(i+1).toLocaleString()}),n+=1;return e.isSquare(parseInt(r.v.square))||(r.v={last:r.v.square}),t.push(r),{points:t,length:n}},forcedDefaults:{n:5e3,scale:createInfNum("6.5"),centerX:infNum(0n,0n),centerY:infNum(0n,0n)},privContext:{direction:0,changeDirection:function(e){return changeDirectionDegrees(e,90)},computeNextPoint:function(e,t,n,o,r){return computeNextPointDegrees(e,1,n,o,r)},isSquare:function(e){const t=Math.sqrt(e);return t==Math.trunc(t)}}},{name:"Squares-1-Step-45-turn",pageTitle:"Squares",calcFrom:"sequence",desc:"Move 1 step forward per integer, but for perfect squares, turn 45 degrees clockwise before moving.  When moving diagonally, we move 1 step on both the x and y axes, so we're actually moving ~1.414 steps diagonally.",computePointsAndLength:function(e){var t=[],n=0;const o=Math.sqrt(2);historyParams.n>1e6&&(historyParams.n=1e6);const r=historyParams;var i=getPoint(0,0);e.direction=270;for(var a=1;a<r.n;a+=1)e.isSquare(a)&&(t.push(i),e.direction=e.changeDirection(e.direction)),i=e.computeNextPoint(e.direction,a,i.x,i.y,{square:(a+1).toLocaleString()}),n+=e.direction%90==0?1:o;return e.isSquare(parseInt(i.v.square))||(i.v={last:i.v.square}),t.push(i),{points:t,length:n}},forcedDefaults:{n:5e3,scale:createInfNum("2.3"),centerX:infNum(0n,0n),centerY:infNum(0n,0n)},privContext:{direction:0,changeDirection:function(e){return changeDirectionDegrees(e,45)},computeNextPoint:function(e,t,n,o,r){return computeNextPointDegrees(e,1,n,o,r)},isSquare:function(e){const t=Math.sqrt(e);return t==Math.trunc(t)}}},{name:"Primes-X-Y-neg-mod-3",pageTitle:"Primes",calcFrom:"sequence",desc:"Where each plotted point <code>(x,y)</code> consists of the primes, in order.  Those points are (2,3), (5,7), (11,13), and so on.<br/><br/>Then we take the sum of the digits of both the <code>x</code> and <code>y</code> of each point.<br/>If that sum, mod 3, is 1, the <code>x</code> is negated.<br/>If that sum, mod 3, is 2, the <code>y</code> is negated.<br/><br/>After applying the negation rule, the first three plotted points become:<br/><code>(2,3)&nbsp;&nbsp;→ sum digits = 5&nbsp;&nbsp;mod 3 = 2 → -y → (2,-3)</code><br/><code>(5,7)&nbsp;&nbsp;→ sum digits = 12 mod 3 = 0 →&nbsp;&nbsp;&nbsp;&nbsp;→ (5,7)</code><br/><code>(11,13)→ sum digits = 6&nbsp;&nbsp;mod 3 = 0 →&nbsp;&nbsp;&nbsp;&nbsp;→ (11,13)</code>",computePointsAndLength:function(e){var t=[],n=0;historyParams.n>1e6&&(historyParams.n=1e6);const o=historyParams;var r=-1,i=getPoint(0,0);t.push(i);for(var a=1;a<o.n;a+=1)if(isPrime(a))if(-1==r)r=a;else{var u=a;const e=(r.toString()+u.toString()).split("");for(var s=0,c=0;c<e.length;c++)s+=e[c];const o=s%3;1==o?r*=-1:2==o&&(u*=-1);const l=getPoint(parseFloat(r),parseFloat(u),{prime:a.toLocaleString()});n+=Math.hypot(l.x-i.x,l.y-i.y),t.push(l),r=-1,i=l}return{points:t,length:n}},forcedDefaults:{n:5e3,scale:createInfNum("0.08"),centerX:infNum(0n,0n),centerY:infNum(0n,0n)},privContext:{}},{name:"Trapped-Knight",pageTitle:"Trapped Knight",calcFrom:"sequence",desc:"On a chessboard, where the squares are numbered in a spiral, find the squares a knight can jump to in sequence where the smallest-numbered square must always be taken.  Previously-visited squares cannot be returned to again.  After more than 2,000 jumps the knight has no valid squares to jump to, so the sequence ends.<br/><br/>Credit to The Online Encyclopedia of Integer Sequences:<br/><a target='_blank' href='https://oeis.org/A316667'>https://oeis.org/A316667</a><br/>and to Numberphile:<br/><a target='_blank' href='https://www.youtube.com/watch?v=RGQe8waGJ4w'>https://www.youtube.com/watch?v=RGQe8waGJ4w</a>",computePointsAndLength:function(e){var t=[],n=0;e.visitedSquares={};const o=historyParams;var r=getPoint(0,0);if(!e.isNumberedSquare(e,r)){let t=r;e.trackNumberedSquare(e,0,r);let n=0,o=90;for(let i=1;i<3562;i+=1)n=e.changeDirection(o),t=e.computeNextPoint(n,1,r.x,r.y),e.isNumberedSquare(e,t)?r=e.computeNextPoint(o,1,r.x,r.y):(o=n,r=t),e.trackNumberedSquare(e,i,r)}var i=getPoint(0,0);t.push(i),e.visitSquare(e,0,i);var a=[],u=-1,s=null;for(let r=0;r<o.n;r+=1){a=e.reachableSquares(i);for(let t=0;t<a.length;t++)(-1==u||e.getSquareNumber(e,a[t])<u)&&(e.isVisited(e,a[t])||(s=a[t],u=e.getSquareNumber(e,s)));if(-1==u)break;n+=Math.hypot(s.x-i.x,s.y-i.y),i=s,t.push(getPoint(i.x,-1*i.y)),e.visitSquare(e,u,i),u=-1}return{points:t,length:n}},forcedDefaults:{n:2016,scale:infNum(15n,0n),centerX:infNum(0n,0n),centerY:infNum(0n,0n)},privContext:{boardPoints:{},visitedSquares:{},trackNumberedSquare:function(e,t,n){e.boardPoints[n.x+"-"+n.y]=t},isNumberedSquare:function(e,t){return t.x+"-"+t.y in e.boardPoints},getSquareNumber:function(e,t){const n=t.x+"-"+t.y;return!n in e.boardPoints&&console.log("MISSING SQUARE - "+n),e.boardPoints[n]},visitSquare:function(e,t,n){e.visitedSquares[n.x+"-"+n.y]=t},isVisited:function(e,t){return t.x+"-"+t.y in e.visitedSquares},changeDirection:function(e){return changeDirectionDegrees(e,-90)},computeNextPoint:function(e,t,n,o){return computeNextPointDegrees(e,t,n,o)},reachableSquares:function(e){return[getPoint(e.x+1,e.y-2),getPoint(e.x+2,e.y-1),getPoint(e.x+2,e.y+1),getPoint(e.x+1,e.y+2),getPoint(e.x-1,e.y-2),getPoint(e.x-2,e.y-1),getPoint(e.x-2,e.y+1),getPoint(e.x-1,e.y+2)]},isSquare:function(e){const t=Math.sqrt(e);return t==Math.trunc(t)}}}];