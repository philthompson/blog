function replaceAllEachChar(subject,replaceThese,replaceWith){var s=subject;for(let i=0;i<replaceThese.length;i++){s=s.replaceAll(replaceThese.charAt(i),replaceWith)}return s}function infNum(value,exponent){return{v:value,e:exponent}}function trimZeroesOld(stringNum){var trimmed=stringNum.trim();const negative=trimmed.startsWith("-");if(negative){trimmed=trimmed.substr(1)}while(trimmed.length>1&&trimmed.startsWith("0")){trimmed=trimmed.substr(1)}if(negative){trimmed="-"+trimmed}const parts=trimmed.split(".");if(parts.length==1){return trimmed}while(parts[1].length>0&&parts[1].endsWith("0")){parts[1]=parts[1].slice(0,-1)}if(parts[1].length==0){return trimmed}return parts[0]+"."+parts[1]}function trimZeroes(stringNum){var parts=stringNum.trim().split(".");const negative=parts[0].startsWith("-");if(negative){parts[0]=parts[0].substr(1)}let leadingZeroes=0;for(let i=0;i<parts[0].length-1;i++){if(parts[0].charAt(i)==="0"){leadingZeroes++}else{break}}parts[0]=parts[0].substring(leadingZeroes);if(parts[0].length==0){parts[0]="0"}if(negative){parts[0]="-"+parts[0]}if(parts.length==1||parts[1].length==0){return parts[0]}let trailingZeroes=0;for(let i=parts[1].length-1;i>=0;i--){if(parts[1].charAt(i)==="0"){trailingZeroes--}else{break}}if(trailingZeroes<0){parts[1]=parts[1].slice(0,trailingZeroes);if(parts[1].length==0){return parts[0]}}return parts[0]+"."+parts[1]}function createInfNum(stringNum){if(stringNum.includes("e")||stringNum.includes("E")){const split=replaceAllEachChar(stringNum,", ","").replaceAll("E","e").split("e");let value=split[0];let exponent=0;if(value.includes(".")){let valSplit=value.split(".");exponent-=valSplit[1].length;value=valSplit[0]+valSplit[1]}exponent+=parseInt(split[1]);return infNum(BigInt(value),BigInt(exponent))}else{var trimmed=trimZeroes(stringNum);const parts=trimmed.split(".");if(parts.length==1){return infNum(BigInt(parts[0]),0n)}return infNum(BigInt(parts[0]+""+parts[1]),BigInt("-"+parts[1].length))}}function copyInfNum(n){return infNum(n.v+0n,n.e+0n)}function infNumMul(a,b){return infNum(a.v*b.v,a.e+b.e)}function normInfNum(argA,argB){var a=copyInfNum(argA);var b=copyInfNum(argB);if(a.e===b.e){return[a,b]}var swapped=false;var s=a;var l=b;if(l.e<s.e){swapped=true;s=b;l=a}var expDiff=l.e-s.e;const newL=infNum(l.v*10n**expDiff,l.e-expDiff);if(swapped){return[newL,s]}return[s,newL]}function normInPlaceInfNum(argA,b,c,d,e,f){let a=copyInfNum(argA);let smallestExponent=a.e;if(b.e<smallestExponent){smallestExponent=b.e}if(c.e<smallestExponent){smallestExponent=c.e}if(d.e<smallestExponent){smallestExponent=d.e}if(e.e<smallestExponent){smallestExponent=e.e}if(f.e<smallestExponent){smallestExponent=f.e}let expDiff=a.e-smallestExponent;a.v=a.v*10n**expDiff;a.e=a.e-expDiff;expDiff=b.e-smallestExponent;b.v=b.v*10n**expDiff;b.e=b.e-expDiff;expDiff=c.e-smallestExponent;c.v=c.v*10n**expDiff;c.e=c.e-expDiff;expDiff=d.e-smallestExponent;d.v=d.v*10n**expDiff;d.e=d.e-expDiff;expDiff=e.e-smallestExponent;e.v=e.v*10n**expDiff;e.e=e.e-expDiff;expDiff=f.e-smallestExponent;f.v=f.v*10n**expDiff;f.e=f.e-expDiff;return a}function infNumAdd(a,b){const norm=normInfNum(a,b);return infNum(norm[0].v+norm[1].v,norm[0].e)}function infNumAddNorm(a,b){return infNum(a.v+b.v,a.e)}function infNumSub(a,b){const norm=normInfNum(a,b);return infNum(norm[0].v-norm[1].v,norm[0].e)}function infNumSubNorm(a,b){return infNum(a.v-b.v,a.e)}function infNumDiv(argA,argB,precis){const p=BigInt(precis);let a=infNumMul(argA,infNum(10n**p,0n));const norm=normInfNum(a,argB);a=norm[0];let b=norm[1];var truncated=infNum(a.v/b.v,a.e-b.e);truncated.e-=p;const power=truncated.v.toString().length;if(power<=precis){return truncated}let truncPower=10n**BigInt(power-precis);truncated.v/=truncPower;truncated.v*=truncPower;return truncated}function infNumEq(a,b){const normalized=normInfNum(a,b);return normalized[0].v===normalized[1].v}function infNumLt(a,b){if(a.v<b.v&&a.e<=b.e){return true}else if(a.v===0n){if(b.v<=0n){return false}else{return true}}else if(b.v===0n){if(a.v<0n){return true}else{return false}}const normalized=normInfNum(a,b);return normalized[0].v<normalized[1].v}function infNumLe(a,b){const normalized=normInfNum(a,b);return normalized[0].v<=normalized[1].v}function infNumGt(a,b){if(a.v>b.v&&a.e>=b.e){return true}else if(a.v===0n){if(b.v<0n){return true}else{return false}}else if(b.v===0n){if(a.v<0n){return false}else{return true}}const normalized=normInfNum(a,b);return normalized[0].v>normalized[1].v}function infNumGe(a,b){const normalized=normInfNum(a,b);return normalized[0].v>=normalized[1].v}function infNumGtNorm(a,b){return a.v>b.v}function infNumToString(n){var value=n.v.toString();if(n.e===0n){return value}if(n.e>0n){let i=0n;while(i<n.e){value=value+"0";i=i+1n}return value}var i=0n;var dec="";var neg=false;if(value.startsWith("-")){neg=true;value=value.substr(1)}while(i>n.e){if(value.length>0){dec=value.slice(-1)+dec;value=value.slice(0,-1)}else{dec="0"+dec}i=i-1n}if(value.length==0){value="0"}if(neg){value="-"+value}return trimZeroes(value+"."+dec)}function infNumExpString(n){return infNumExpStringTruncToLen(n,-1)}function infNumExpStringTruncToLen(n,truncDecimals){var value=n.v.toString();let negative=false;if(n.v<0){negative=true;value=value.substring(1)}let bd=value.length;let ad=value.length-1;let finalExponent=n.e+BigInt(ad);let decimal=trimZeroes(value.substring(0,1)+"."+value.substring(1));if(!decimal.includes(".")){decimal=decimal+".0"}if(truncDecimals>0){decimal=decimal.substring(0,truncDecimals+2)}if(negative){decimal="-"+decimal}return decimal+"e"+finalExponent.toString()}function createInfNumFromExpStr(s){const split=s.split("e");const decSplit=split[0].split(".");let exp=BigInt(split[1]);exp-=BigInt(decSplit[1].length);let val=BigInt(decSplit[0]+decSplit[1]);return infNum(val,exp)}function infNumFastStr(n){let nCopy=copyInfNum(n);while(nCopy.v%10n===0n&&nCopy.v!==0n){nCopy.v/=10n;nCopy.e+=1n}return nCopy.v.toString(16)+"E"+nCopy.e.toString(16)}function createInfNumFromFastStr(s){const split=s.split("E");let negative=false;if(split[0].startsWith("-")){negative=true;split[0]=split[0].substring(1)}let val=BigInt("0x"+split[0]);if(negative){val=val*-1n}negative=false;if(split[1].startsWith("-")){negative=true;split[1]=split[1].substring(1)}let exp=BigInt("0x"+split[1]);if(negative){exp=exp*-1n}return infNum(val,exp)}function infNumTruncateToLen(n,len){var truncatedExpString=infNumExpStringTruncToLen(n,len-1);return createInfNum(truncatedExpString)}function infNumTruncateToLenOldMaybeBad(n,len){var a=copyInfNum(n);const orig=a.v.toString();if(orig.length<=len){return a}a.v=BigInt(a.v.toString().substring(0,len));a.e=a.e+BigInt(orig.length-len);return a}function infNumMagnitude(n){var value=n.v.toString();let afterDecimal=n.v<0?value.length-2:value.length-1;let finalExponent=parseInt(n.e)+afterDecimal;return finalExponent}var infNumSqrt10=infNum(31622776601683795n,-16n);function infNumRoughSqrt(a){if(a.v===0n){return a}if(a.e%2n===0n){return{v:bigIntRoughSqrt(a.v),e:a.e/2n}}else{return infNumMul(infNumSqrt10,{v:bigIntRoughSqrt(a.v),e:Math.floor(a.e/2)})}}function bigIntRoughSqrt(a){if(a<0n){throw"cannot take rough square root of negative value"}let digits=a.toString().length;const mag=digits-1;let mantissa=a*10n;digits++;while(mantissa<100n){mantissa*=10n;digits++}mantissa=mantissa/10n**BigInt(digits-3);const floatMantissa=parseFloat(mantissa)/100;const sqrt1000=mag%2===0?BigInt(Math.round(Math.sqrt(floatMantissa)*1e3))*10n**BigInt(mag/2):BigInt(Math.round(Math.sqrt(floatMantissa)*1e3))*10n**BigInt(Math.floor(mag/2))*3n;return sqrt1000/BigInt(1000n)}