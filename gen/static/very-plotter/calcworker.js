var useWorkers=true;if(!self.Worker){useWorkers=false;self.postMessage({subworkerNoWorky:true});self.close()}if(!self.structuredClone){BigInt.prototype.toJSON=function(){return this.toString()};self.structuredClone=function(obj){return JSON.parse(JSON.stringify(obj))}}const forceWorkerReloadUrlParam="force-worker-reload=true";const forceWorkerReload=self.location.toString().includes(forceWorkerReloadUrlParam);const urlParams=new URLSearchParams(self.location.search);const appVersion=urlParams.has("v")?urlParams.get("v"):"unk";if(forceWorkerReload){importScripts("infnum.js?v="+appVersion+"&"+forceWorkerReloadUrlParam+"&t="+Date.now());importScripts("floatexp.js?v="+appVersion+"&"+forceWorkerReloadUrlParam+"&t="+Date.now());importScripts("mathiface.js?v="+appVersion+"&"+forceWorkerReloadUrlParam+"&t="+Date.now());importScripts("plots.js?v="+appVersion+"&"+forceWorkerReloadUrlParam+"&t="+Date.now())}else{importScripts("infnum.js?v="+appVersion);importScripts("floatexp.js?v="+appVersion);importScripts("mathiface.js?v="+appVersion);importScripts("plots.js?v="+appVersion)}const plotsByName={};for(let i=0;i<plots.length;i++){plotsByName[plots[i].name]=plots[i]}const allCachedIndicesArray=[-1];const startPassNumber=0;const windowCalc={timeout:null,plot:null,pointCalcFunction:null,eachPixUnits:null,edges:null,edgesM:null,n:null,precision:null,algorithm:null,math:null,passNumber:null,lineWidth:null,finalWidth:null,chunksComplete:null,canvasWidth:null,canvasHeight:null,xPixelChunks:null,pointsCache:null,pointsCacheAlgorithm:null,cacheScannedChunks:null,cacheScannedChunksCursor:null,passTotalPoints:null,passCachedPoints:null,totalChunks:null,workersCount:null,workers:null,minWorkersCount:null,maxWorkersCount:null,plotId:null,stopped:true,referencePx:null,referencePy:null,referencePeriod:null,referenceOrbit:null,referenceOrbitPrecision:null,referenceOrbitN:null,referenceOrbitSmooth:null,referenceBlaTables:null,referenceBlaN:null,referenceBottomLeftDeltaX:null,referenceBottomLeftDeltaY:null,saCoefficients:null,saCoefficientsN:null,saCoefficientsEdges:null,saCoefficientsParams:null,passBlaPixels:null,passBlaIterationsSkipped:null,passBlaSkips:null,totalBlaPixels:null,totalBlaIterationsSkipped:null,totalBlaSkips:null,referenceBlaEpsilon:null,setupStage:null,setupStageState:null,setupStageIsStarted:null,setupStageIsFinished:null,caching:null,smooth:null};const setupStages={checkRefOrbit:0,calcRefOrbit:1,checkBlaCoeff:2,calcBlaCoeff:3,checkSaCoeff:4,calcSaCoeff:5,done:6};self.onmessage=function(e){if(!useWorkers){self.postMessage({subworkerNoWorky:true});return}console.log("got message ["+e.data.t+"]");if(e.data.t=="worker-calc"){runCalc(e.data.v)}else if(e.data.t=="chunk-ordering"){windowCalc.chunkOrdering=e.data.v;updateRunningChunksOrdering()}else if(e.data.t=="workers-count"){updateWorkerCount(e.data.v)}else if(e.data.t=="wipe-cache"){windowCalc.pointsCache=new Map}else if(e.data.t=="wipe-ref-orbit"){wipeReferenceOrbitStuff()}else if(e.data.t=="stop"){windowCalc.stopped=true;stopAndRemoveAllWorkers()}};function runCalc(msg){windowCalc.plotId=msg.plotId;windowCalc.plot=msg.plot;windowCalc.stopped=false;windowCalc.eachPixUnits=msg.eachPixUnits;windowCalc.eachPixUnitsM=msg.eachPixUnitsM;windowCalc.edges={left:msg.leftEdge,right:msg.rightEdge,top:msg.topEdge,bottom:msg.bottomEdge};windowCalc.edgesM={left:msg.leftEdgeM,right:msg.rightEdgeM,top:msg.topEdgeM,bottom:msg.bottomEdgeM};windowCalc.n=msg.n;windowCalc.precision=msg.precision;windowCalc.algorithm=msg.algorithm;windowCalc.math=selectMathInterfaceFromAlgorithm(windowCalc.algorithm);windowCalc.passNumber=startPassNumber-1;windowCalc.lineWidth=msg.startWidth*2;windowCalc.finalWidth=msg.finalWidth;windowCalc.chunksComplete=0;windowCalc.canvasWidth=msg.canvasWidth;windowCalc.canvasHeight=msg.canvasHeight;windowCalc.chunkOrdering=msg.chunkOrdering;windowCalc.smooth=msg.smooth;windowCalc.caching=false;if(windowCalc.pointsCache===null||!windowCalc.caching||windowCalc.pointsCacheAlgorithm!==null&&windowCalc.pointsCacheAlgorithm!=windowCalc.algorithm){windowCalc.pointsCache=new Map}windowCalc.pointsCacheAlgorithm=windowCalc.algorithm;windowCalc.totalChunks=null;windowCalc.workersCount=msg.workers;windowCalc.workers=[];windowCalc.minWorkersCount=windowCalc.workersCount;windowCalc.maxWorkersCount=windowCalc.workersCount;for(let i=0;i<windowCalc.workersCount;i++){if(forceWorkerReload){windowCalc.workers.push(new Worker("calcsubworker.js?v="+appVersion+"&"+forceWorkerReloadUrlParam+"&t="+Date.now()))}else{windowCalc.workers.push(new Worker("calcsubworker.js?v="+appVersion))}windowCalc.workers[i].onmessage=onSubWorkerMessage}if(windowCalc.algorithm.includes("basic-")){windowCalc.referencePx=null;windowCalc.referencePy=null;windowCalc.referenceOrbit=null;windowCalc.referenceBlaTables=null;windowCalc.saCoefficients=null;calculatePass()}else{if(windowCalc.timeout!=null){clearTimeout(windowCalc.timeout)}windowCalc.timeout=setTimeout(kickoffSetupTasks,250)}}function wipeReferenceOrbitStuff(){windowCalc.referenceOrbit=null;windowCalc.saCoefficients=null;windowCalc.referenceBlaTables=null}function setupCheckReferenceOrbit(){sendStatusMessage("Finding reference point");let newReferencePx=infNumAdd(windowCalc.edges.left,infNumMul(windowCalc.eachPixUnits,infNum(BigInt(Math.floor(windowCalc.canvasWidth/2)),0n)));let newReferencePy=infNumAdd(windowCalc.edges.bottom,infNumMul(windowCalc.eachPixUnits,infNum(BigInt(Math.floor(windowCalc.canvasHeight/2)),0n)));let refPointHasMoved=false;if(windowCalc.referencePx===null||windowCalc.referencePy===null){refPointHasMoved=true}else{let xDiff=infNumSub(windowCalc.referencePx,newReferencePx);let yDiff=infNumSub(windowCalc.referencePy,newReferencePy);let squaredDiff=infNumAdd(infNumMul(xDiff,xDiff),infNumMul(yDiff,yDiff));let maxAllowablePixelsMove=windowCalc.referencePeriod>0&&windowCalc.algorithm.includes("bla-")?Math.ceil(Math.min(windowCalc.canvasHeight,windowCalc.canvasWidth)*.49):Math.ceil(Math.min(windowCalc.canvasHeight,windowCalc.canvasWidth)*.15);let maxAllowableMove=infNumMul(windowCalc.eachPixUnits,infNum(BigInt(maxAllowablePixelsMove),0n));maxAllowableMove=infNumMul(maxAllowableMove,maxAllowableMove);if(infNumGt(squaredDiff,maxAllowableMove)){refPointHasMoved=true;console.log("the previous ref orbit is NOT within ["+maxAllowablePixelsMove+"] pixels of the center, so we need a new ref orbit")}else{console.log("the previous ref orbit is within ["+maxAllowablePixelsMove+"] pixels of the center, so it's still valid");if(windowCalc.referencePeriod>0&&windowCalc.algorithm.includes("bla-")){setMinibrotNucleusMessage({x:windowCalc.referencePx,y:windowCalc.referencePy,period:windowCalc.referencePeriod})}}}if(windowCalc.referenceOrbitN===null||windowCalc.referenceOrbitN<windowCalc.n||windowCalc.referenceOrbitPrecision===null||windowCalc.referenceOrbitPrecision/windowCalc.precision<.98||windowCalc.referenceOrbitSmooth!==windowCalc.smooth||windowCalc.referenceOrbit===null||refPointHasMoved){windowCalc.referencePx=newReferencePx;windowCalc.referencePy=newReferencePy;wipeReferenceOrbitStuff()}else{console.log("re-using previously-calculated reference orbit, with ["+windowCalc.referenceOrbit.length+"] iterations, for point:");console.log("referencePx: "+infNumToString(windowCalc.referencePx));console.log("referencePy: "+infNumToString(windowCalc.referencePy));return false}return true}function setupReferenceOrbit(state){if(state===null||!state.done){if(state===null){state={minibrotFindingState:null,computeRefOrbitState:null,status:"",done:false}}const findPeriod=windowCalc.algorithm.includes("bla-");if(!findPeriod){windowCalc.referencePeriod=-1}else{if(state.minibrotFindingState===null){state.rectHalfX=infNumMul(windowCalc.eachPixUnits,infNum(BigInt(Math.floor(windowCalc.canvasWidth/2)),0n));state.rectHalfY=infNumMul(windowCalc.eachPixUnits,infNum(BigInt(Math.floor(windowCalc.canvasHeight/2)),0n))}const getNthIterationAndDerivative=plotsByName[windowCalc.plot].getNthIterationAndDerivative;const newtonsMethod=plotsByName[windowCalc.plot].newtonsMethod;if(state.minibrotFindingState===null||!state.minibrotFindingState.done){state.minibrotFindingState=plotsByName[windowCalc.plot].findMinibrotWithBallArithmetic1stOrderAndNewton(windowCalc.n,windowCalc.precision,windowCalc.algorithm,windowCalc.referencePx,windowCalc.referencePy,state.rectHalfX,state.rectHalfY,getNthIterationAndDerivative,newtonsMethod,state.minibrotFindingState);sendStatusMessage(state.minibrotFindingState.status);if(state.minibrotFindingState.done){const foundMinibrotNucleus=state.minibrotFindingState.nucleus;if(foundMinibrotNucleus===null){console.log("no found newton nucleus is within the window");windowCalc.referencePeriod=-1}else{windowCalc.referencePeriod=foundMinibrotNucleus.period;windowCalc.referencePx=foundMinibrotNucleus.x;windowCalc.referencePy=foundMinibrotNucleus.y;console.log("found ref x/y/period!");setMinibrotNucleusMessage({x:foundMinibrotNucleus.x,y:foundMinibrotNucleus.y,period:foundMinibrotNucleus.period})}}return state}}if(state.computeRefOrbitState===null||!state.computeRefOrbitState.done){state.computeRefOrbitState=plotsByName[windowCalc.plot].computeReferenceOrbit(windowCalc.n,windowCalc.precision,windowCalc.algorithm,windowCalc.referencePx,windowCalc.referencePy,windowCalc.referencePeriod,windowCalc.smooth,state.computeRefOrbitState);sendStatusMessage(state.computeRefOrbitState.status);if(state.computeRefOrbitState.done){state.done=true}else{return state}}}if(state.done){windowCalc.referenceOrbit=state.computeRefOrbitState.orbit;windowCalc.referenceOrbitN=windowCalc.n;windowCalc.referenceOrbitPrecision=windowCalc.precision;windowCalc.referenceOrbitSmooth=windowCalc.smooth;console.log("calculated new "+(windowCalc.referencePeriod===-1?"middle":"periodic")+" reference orbit, with ["+windowCalc.referenceOrbit.length+"] iterations, for point:");console.log("referencePx: "+infNumToString(windowCalc.referencePx));console.log("referencePy: "+infNumToString(windowCalc.referencePy))}return state}function setupCheckBlaCoefficients(){if(windowCalc.algorithm.includes("bla-")){windowCalc.totalBlaPixels=0;windowCalc.totalBlaIterationsSkipped=0;windowCalc.totalBlaSkips=0;const algoEpsilon=getBLAEpsilonFromAlgorithm(windowCalc.algorithm);if(windowCalc.referenceBlaTables===null||windowCalc.n!==windowCalc.referenceBlaN||windowCalc.referenceBlaWindowEdges===null||!infNumEq(windowCalc.edges.top,windowCalc.referenceBlaWindowEdges.top)||!infNumEq(windowCalc.edges.bottom,windowCalc.referenceBlaWindowEdges.bottom)||!infNumEq(windowCalc.edges.left,windowCalc.referenceBlaWindowEdges.left)||!infNumEq(windowCalc.edges.right,windowCalc.referenceBlaWindowEdges.right)||algoEpsilon!==null&&!infNumEq(algoEpsilon,windowCalc.referenceBlaEpsilon)){return true}else{console.log("re-using previously-calculated BLA coefficient tables")}}return false}function findFathestCornerFromPoint(infNumComplexPt,edges){let testPoint={x:edges.left,y:edges.top};let dist=infNumMath.complexAbs(infNumMath.complexSub(infNumComplexPt,testPoint));let farthestPoint=structuredClone(testPoint);let farthestDist=structuredClone(dist);testPoint={x:edges.left,y:edges.bottom};dist=infNumMath.complexAbs(infNumMath.complexSub(infNumComplexPt,testPoint));if(infNumGt(dist,farthestDist)){farthestPoint=structuredClone(testPoint);farthestDist=structuredClone(dist)}testPoint={x:edges.right,y:edges.top};dist=infNumMath.complexAbs(infNumMath.complexSub(infNumComplexPt,testPoint));if(infNumGt(dist,farthestDist)){farthestPoint=structuredClone(testPoint);farthestDist=structuredClone(dist)}testPoint={x:edges.right,y:edges.bottom};dist=infNumMath.complexAbs(infNumMath.complexSub(infNumComplexPt,testPoint));if(infNumGt(dist,farthestDist)){farthestPoint=structuredClone(testPoint)}return farthestPoint}function getTestPointsInOrderFromAToB(infNumComplexA,infNumComplexB,windowCalcMath,precis){const pointsDifference=infNumMath.complexSub(infNumComplexB,infNumComplexA);const testLineLength=infNumMath.complexAbs(pointsDifference);const testLinePixels=infNumDiv(testLineLength,windowCalc.eachPixUnits,precis);const firstThirdPointsFloat=floatMath.createFromInfNum(infNumDiv(testLinePixels,infNum(64n,0n),10));const firstThirdPoints=BigInt(Math.round(firstThirdPointsFloat));console.log("test line covers ["+infNumToString(infNumTruncateToLen(testLinePixels,15))+"] pixels, so dividing the far third of that line into ["+firstThirdPoints+"] test points");const stepDiv=firstThirdPoints*4n*3n;const firstThirdSteps=firstThirdPoints*4n;const secondThirdSteps=firstThirdSteps*2n;const step=infNumMath.complexRealDiv(pointsDifference,infNum(stepDiv,0n),precis);let points=[];let testPointComplex;let testPointDelta;for(let i=0n;i<stepDiv;i+=1n){if(i<firstThirdSteps&&i%4n===0n||i>=firstThirdSteps&&i<secondThirdSteps&&i%2n===0n||i>=secondThirdSteps){testPointComplex=infNumMath.complexAdd(infNumComplexA,infNumMath.complexRealMul(step,infNum(i,0n)));testPointDelta=infNumMath.complexSub(testPointComplex,infNumComplexB);points.push({dx:windowCalcMath.createFromInfNum(testPointDelta.x),dy:windowCalcMath.createFromInfNum(testPointDelta.y),complex:testPointComplex})}}return points}function setupBlaCoefficients(state){if(state===null||!state.done){if(state===null){windowCalc.referenceBlaTables=null;sendStatusMessage("Calculating BLA coefficient tables")}const algoSpecifiedEpsilon=getBLAEpsilonFromAlgorithm(windowCalc.algorithm);if(algoSpecifiedEpsilon!==null){const algoSpecifiedEpsilonStr=infNumExpStringTruncToLen(algoSpecifiedEpsilon,2);while(state===null||!state.done){state=plotsByName[windowCalc.plot].computeBlaTables(windowCalc.algorithm,null,windowCalc.referenceOrbit,windowCalc.referencePx,windowCalc.referencePy,windowCalc.edges,state);sendStatusMessage("for ε="+algoSpecifiedEpsilonStr+": "+state.status)}if(state.done){windowCalc.referenceBlaN=windowCalc.n;windowCalc.referenceBlaWindowEdges=structuredClone(windowCalc.edges);windowCalc.referenceBlaTables=state.blas;windowCalc.referenceBlaEpsilon=state.infNumEpsilon}return state}const refPoint={x:windowCalc.referencePx,y:windowCalc.referencePy};const farthestCorner=findFathestCornerFromPoint(refPoint,windowCalc.edges);const testPoints=getTestPointsInOrderFromAToB(farthestCorner,refPoint,windowCalc.math,windowCalc.precision);console.log("testing ["+testPoints.length+"] points to find the best BLA epsilon");const perturbAlgo="perturb-"+windowCalc.math.name;const nullBlaTables=null;const nullSaCoefficients=null;const testPointsPerturb=[];let epsilon=windowCalc.math.name==="float"?infNum(1n,-54n):infNum(1n,-129n);let epsilonStr=infNumExpStringTruncToLen(epsilon,2);let totalTestPointBLAIterSkips=0;let bestEpsilon=null;let bestTotalTestPointBLAIterSkips=0;let smallestBadEpsilon=null;let testPointsCursor=0;const totalTestPoints=testPoints.length;let dx,dy,blaResult;while(testPointsCursor<totalTestPoints){if(state===null){while(state===null||!state.done){state=plotsByName[windowCalc.plot].computeBlaTables(windowCalc.algorithm,epsilon,windowCalc.referenceOrbit,windowCalc.referencePx,windowCalc.referencePy,windowCalc.edges,state);sendStatusMessage("For ε="+epsilonStr+": "+state.status)}}if(testPointsPerturb[testPointsCursor]===undefined){testPointsPerturb[testPointsCursor]=plotsByName[windowCalc.plot].computeBoundPointColorPerturbOrBla(windowCalc.n,windowCalc.precision,testPoints[testPointsCursor].dx,testPoints[testPointsCursor].dy,perturbAlgo,windowCalc.referencePx,windowCalc.referencePy,windowCalc.referenceOrbit,nullBlaTables,nullSaCoefficients,windowCalc.smooth)}blaResult=plotsByName[windowCalc.plot].computeBoundPointColorPerturbOrBla(windowCalc.n,windowCalc.precision,testPoints[testPointsCursor].dx,testPoints[testPointsCursor].dy,windowCalc.algorithm,windowCalc.referencePx,windowCalc.referencePy,windowCalc.referenceOrbit,state.blas,nullSaCoefficients,windowCalc.smooth);totalTestPointBLAIterSkips+=blaResult.blaItersSkipped;sendStatusMessage("Tested "+Math.round(testPointsCursor*100/totalTestPoints)+"% of test pts for ε="+epsilonStr);if(Math.abs(testPointsPerturb[testPointsCursor].colorpct-blaResult.colorpct)/testPointsPerturb[testPointsCursor].colorpct<1e-5){testPointsCursor++;if(testPointsCursor===totalTestPoints){if(bestEpsilon===null||infNumGt(epsilon,bestEpsilon)&&totalTestPointBLAIterSkips>bestTotalTestPointBLAIterSkips){bestEpsilon=epsilon;bestTotalTestPointBLAIterSkips=totalTestPointBLAIterSkips}else if(smallestBadEpsilon===null||infNumLt(epsilon,smallestBadEpsilon)){smallestBadEpsilon=epsilon}state=null}}else{if(smallestBadEpsilon===null||infNumLt(epsilon,smallestBadEpsilon)){smallestBadEpsilon=epsilon}state=null}if(state===null){if(smallestBadEpsilon===null){epsilon=infNum(epsilon.v,epsilon.e/2n)}else if(bestEpsilon===null){epsilon=infNum(epsilon.v,epsilon.e*2n)}else{let exponentDiff=smallestBadEpsilon.e-bestEpsilon.e;if(exponentDiff<2n){epsilon=infNum(bestEpsilon.v,bestEpsilon.e-2n);console.log("final bestEpsilon found to be ["+infNumExpStringTruncToLen(bestEpsilon,2)+"]");console.log("using adjusted epsilon ["+infNumExpStringTruncToLen(epsilon,2)+"] to render the image");while(state===null||!state.done){state=plotsByName[windowCalc.plot].computeBlaTables(windowCalc.algorithm,epsilon,windowCalc.referenceOrbit,windowCalc.referencePx,windowCalc.referencePy,windowCalc.edges,state);sendStatusMessage("For ε="+epsilonStr+": "+state.status)}break}else{epsilon=infNum(smallestBadEpsilon.v,smallestBadEpsilon.e-(exponentDiff>>1n))}}epsilonStr=infNumExpStringTruncToLen(epsilon,2);totalTestPointBLAIterSkips=0;testPointsCursor=0;console.log("trying new epsilon ["+epsilonStr+"]");sendStatusMessage("Trying new ε of "+epsilonStr)}}}if(state.done){windowCalc.referenceBlaN=windowCalc.n;windowCalc.referenceBlaWindowEdges=structuredClone(windowCalc.edges);windowCalc.referenceBlaTables=state.blas;windowCalc.referenceBlaEpsilon=state.infNumEpsilon}return state}function setupCheckSaCoefficients(){if(windowCalc.algorithm.includes("sapx")){let sapxParams=windowCalc.algorithm.split("-").find((e=>e.startsWith("sapx")));if(windowCalc.saCoefficients===null||windowCalc.saCoefficientsEdges===null||windowCalc.n!==windowCalc.saCoefficientsN||windowCalc.saCoefficientsParams===null||windowCalc.saCoefficientsParams!=sapxParams||!infNumEq(windowCalc.edges.left,windowCalc.saCoefficientsEdges.left)||!infNumEq(windowCalc.edges.right,windowCalc.saCoefficientsEdges.right)||!infNumEq(windowCalc.edges.top,windowCalc.saCoefficientsEdges.top)||!infNumEq(windowCalc.edges.bottom,windowCalc.saCoefficientsEdges.bottom)){return true}else{console.log("re-using previously-calculated SA coefficients")}}else{}return false}function setupSaCoefficients(state){if(state===null||!state.done){if(state===null){windowCalc.saCoefficients=null;sendStatusMessage("Calculating and testing SA coefficients")}state=plotsByName[windowCalc.plot].computeSaCoefficients(windowCalc.precision,windowCalc.algorithm,windowCalc.referencePx,windowCalc.referencePy,windowCalc.referenceOrbit,windowCalc.edges,state);sendStatusMessage(state.status)}if(state.done){windowCalc.saCoefficientsN=windowCalc.n;windowCalc.saCoefficientsEdges=structuredClone(windowCalc.edges);windowCalc.saCoefficients=state.saCoefficients;windowCalc.saCoefficientsParams=windowCalc.algorithm.split("-").find((e=>e.startsWith("sapx")))}return state}function kickoffSetupTasks(){if(windowCalc.timeout!=null){clearTimeout(windowCalc.timeout)}windowCalc.setupStage=0;windowCalc.timeout=setInterval(runSetupTasks,5)}function runSetupTasks(){if(windowCalc.stopped||windowCalc.setupStage>=setupStages.done){if(windowCalc.timeout!=null){clearTimeout(windowCalc.timeout)}if(!windowCalc.stopped){setupPixelPositionDelta();calculatePass()}return}else if(windowCalc.setupStage===setupStages.checkRefOrbit){if(!setupCheckReferenceOrbit()){windowCalc.setupStage++}windowCalc.setupStageIsFinished=true}else if(windowCalc.setupStage===setupStages.calcRefOrbit){if(!windowCalc.setupStageIsStarted){windowCalc.setupStageState=null;windowCalc.setupStageIsStarted=true}if(!windowCalc.setupStageIsFinished){windowCalc.setupStageState=setupReferenceOrbit(windowCalc.setupStageState)}if(windowCalc.setupStageState.done){windowCalc.setupStageIsFinished=true}}else if(windowCalc.setupStage===setupStages.checkBlaCoeff){if(!setupCheckBlaCoefficients()){windowCalc.setupStage++}windowCalc.setupStageIsFinished=true}else if(windowCalc.setupStage===setupStages.calcBlaCoeff){if(!windowCalc.setupStageIsStarted){windowCalc.setupStageState=null;windowCalc.setupStageIsStarted=true}if(!windowCalc.setupStageIsFinished){windowCalc.setupStageState=setupBlaCoefficients(windowCalc.setupStageState)}if(windowCalc.setupStageState.done){windowCalc.setupStageIsFinished=true}}else if(windowCalc.setupStage===setupStages.checkSaCoeff){if(!setupCheckSaCoefficients()){windowCalc.setupStage++}windowCalc.setupStageIsFinished=true}else if(windowCalc.setupStage===setupStages.calcSaCoeff){if(!windowCalc.setupStageIsStarted){windowCalc.setupStageState=null;windowCalc.setupStageIsStarted=true}if(!windowCalc.setupStageIsFinished){windowCalc.setupStageState=setupSaCoefficients(windowCalc.setupStageState)}if(windowCalc.setupStageState.done){windowCalc.setupStageIsFinished=true}}else{console.log("unexpected calcworker setup stage ["+windowCalc.setupStage+"]... stopping setup");windowCalc.setupStage=setupStages.done}if(windowCalc.setupStageIsFinished){windowCalc.setupStageIsStarted=false;windowCalc.setupStageIsFinished=false;windowCalc.setupStage++}}function stopAndRemoveAllWorkers(){if(windowCalc.timeout!=null){clearTimeout(windowCalc.timeout)}if(windowCalc.workers===null){return}for(let i=0;i<windowCalc.workers.length;i++){windowCalc.workers[i].terminate()}windowCalc.workers=null}function updateWorkerCount(msg){windowCalc.workersCount=msg;if(windowCalc.workers===null){return}if(windowCalc.minWorkersCount>windowCalc.workersCount){windowCalc.minWorkersCount=windowCalc.workersCount}if(windowCalc.maxWorkersCount<windowCalc.workersCount){windowCalc.maxWorkersCount=windowCalc.workersCount}for(let i=windowCalc.workers.length+1;i<=windowCalc.workersCount;i++){let newWorker=null;if(forceWorkerReload){newWorker=new Worker("calcsubworker.js?v="+appVersion+"&"+forceWorkerReloadUrlParam+"&t="+Date.now())}else{newWorker=new Worker("calcsubworker.js?v="+appVersion)}windowCalc.workers.push(newWorker);newWorker.onmessage=onSubWorkerMessage;assignChunkToWorker(newWorker)}}function removeWorkerIfNecessary(worker){if(windowCalc.workers.length<=windowCalc.workersCount){return false}const index=windowCalc.workers.indexOf(worker);if(index<0){return false}windowCalc.workers.splice(index,1);return true}var calculatePass=function(){if(windowCalc.stopped){return}calculateWindowPassChunks();for(const worker of windowCalc.workers){assignChunkToWorker(worker)}};function setupPixelPositionDelta(){windowCalc.referenceBottomLeftDeltaX=null;windowCalc.referenceBottomLeftDeltaY=null;if(windowCalc.algorithm.includes("basic")||windowCalc.referencePx===null||windowCalc.referencePy===null){return}windowCalc.referenceBottomLeftDeltaX=windowCalc.math.createFromInfNum(infNumSub(windowCalc.edges.left,windowCalc.referencePx));windowCalc.referenceBottomLeftDeltaY=windowCalc.math.createFromInfNum(infNumSub(windowCalc.edges.bottom,windowCalc.referencePy))}function buildChunkId(chunkPos){return infNumFastStr(chunkPos.x)+","+infNumFastStr(chunkPos.y)}var assignChunkToWorker=function(worker){if(windowCalc.stopped||windowCalc.xPixelChunks===null||windowCalc.xPixelChunks.length===0){return}if(!windowCalc.caching){let nextChunk=windowCalc.xPixelChunks.shift();let subWorkerMsg={plotId:windowCalc.plotId,chunk:nextChunk,cachedIndices:[],algorithm:windowCalc.algorithm,smooth:windowCalc.smooth};worker.postMessage({t:"compute-chunk",v:subWorkerMsg});return}let nextChunk=windowCalc.xPixelChunks.shift();windowCalc.cacheScannedChunksCursor--;const chunkId=buildChunkId(nextChunk.chunkPos);let cacheScan=windowCalc.cacheScannedChunks.get(chunkId);if(cacheScan===undefined){scanCacheForChunk(nextChunk);cacheScan=windowCalc.cacheScannedChunks.get(chunkId)}let subWorkerMsg={plotId:windowCalc.plotId,chunk:nextChunk,cachedIndices:cacheScan.size===nextChunk.chunkLen?allCachedIndicesArray:Array.from(cacheScan.keys()).sort(((a,b)=>a-b))};worker.postMessage({t:"compute-chunk",v:subWorkerMsg});scanCacheForChunkBeyondCursor();scanCacheForChunkBeyondCursor()};function scanCacheForChunkBeyondCursor(){if(windowCalc.cacheScannedChunksCursor>=windowCalc.xPixelChunks.length-1||windowCalc.xPixelChunks.length===0){return}windowCalc.cacheScannedChunksCursor++;if(windowCalc.cacheScannedChunksCursor<0){windowCalc.cacheScannedChunksCursor=0}scanCacheForChunk(windowCalc.xPixelChunks[windowCalc.cacheScannedChunksCursor])}function scanCacheForChunk(chunk){const pxStr=infNumFastStr(chunk.chunkPos.x);const pyStr=infNumFastStr(chunk.chunkPos.y);const id=pxStr+","+pyStr;let py=chunk.chunkPos.y;let incY=chunk.chunkInc.y;let norm=normInfNum(py,incY);py=norm[0];incY=norm[1];const cachedValues=new Map;let cachedValue=null;const xCache=windowCalc.pointsCache.get(pxStr);if(xCache!==undefined){for(let i=0;i<chunk.chunkLen;i++){cachedValue=xCache.get(infNumFastStr(py));if(cachedValue!==undefined){cachedValues.set(i,cachedValue)}py=infNumAddNorm(py,incY)}}windowCalc.cacheScannedChunks.set(id,cachedValues)}function cacheComputedPointsInChunk(chunk){if(chunk.results.length===0){return 0}if(!windowCalc.caching){return chunk.results.length}let count=0;const pxStr=infNumFastStr(chunk.chunkPos.x);let xCache=windowCalc.pointsCache.get(pxStr);if(xCache===undefined){windowCalc.pointsCache.set(pxStr,new Map);xCache=windowCalc.pointsCache.get(pxStr)}let py=chunk.chunkPos.y;let incY=chunk.chunkInc.y;let norm=normInfNum(py,incY);py=norm[0];incY=norm[1];let calculatedValue=null;for(let i=0;i<chunk.chunkLen;i++){calculatedValue=chunk.results[i];if(calculatedValue!==undefined){count++;xCache.set(infNumFastStr(py),calculatedValue)}py=infNumAddNorm(py,incY)}return count}var onSubWorkerMessage=function(msg){if(msg.data.t=="completed-chunk"){handleSubworkerCompletedChunk(msg)}else if(msg.data.t=="send-reference-orbit"){handleReferenceOrbitRequest(msg)}else if(msg.data.t=="send-bla-tables"){handleBlaTablesRequest(msg)}else if(msg.data.t=="send-sa-coefficients"){handleSaCoefficientsRequest(msg)}else{console.log("worker received unknown message from subworker:",e)}};function handleReferenceOrbitRequest(msg){const worker=msg.target;worker.postMessage({t:"reference-orbit",v:{referencePx:windowCalc.referencePx,referencePy:windowCalc.referencePy,referenceOrbit:windowCalc.referenceOrbit,referencePlotId:windowCalc.plotId}})}function handleBlaTablesRequest(msg){const worker=msg.target;worker.postMessage({t:"bla-tables",v:{referencePx:windowCalc.referencePx,referencePy:windowCalc.referencePy,referenceBlaTables:windowCalc.referenceBlaTables,referencePlotId:windowCalc.plotId}})}function handleSaCoefficientsRequest(msg){const worker=msg.target;worker.postMessage({t:"sa-coefficients",v:{referencePx:windowCalc.referencePx,referencePy:windowCalc.referencePy,saCoefficients:windowCalc.saCoefficients,referencePlotId:windowCalc.plotId}})}function handleSubworkerCompletedChunk(msg){const isOutdatedWorker=msg.data.v.plotId!==windowCalc.plotId;if(!isOutdatedWorker){windowCalc.chunksComplete++}const worker=msg.target;const wasWorkerRemoved=removeWorkerIfNecessary(worker);if(windowCalc.stopped){return}if(!wasWorkerRemoved&&windowCalc.chunksComplete<windowCalc.totalChunks){assignChunkToWorker(worker)}if(!isOutdatedWorker){settleChunkWithCacheAndPublish({data:msg.data.v})}if(windowCalc.chunksComplete>=windowCalc.totalChunks){if(windowCalc.passBlaPixels>0){if(windowCalc.passBlaIterationsSkipped>0){console.log("for entire pass, ["+windowCalc.passBlaPixels.toLocaleString()+"] pixels skipped ["+windowCalc.passBlaIterationsSkipped.toLocaleString()+"] iters with BLA, avgs: ["+Math.floor(windowCalc.passBlaIterationsSkipped/windowCalc.passBlaPixels)+"] per pixel, ["+Math.floor(windowCalc.passBlaIterationsSkipped/windowCalc.passBlaSkips)+"] per skip")}else{console.log("for entire pass, no pixels had BLA iteration skips")}}if(isImageComplete()){cleanUpWindowCache()}else{calculatePass()}}}function settleChunkWithCacheAndPublish(msg){let workersCountToReport=windowCalc.minWorkersCount.toString();if(windowCalc.maxWorkersCount>windowCalc.minWorkersCount){workersCountToReport+="-"+windowCalc.maxWorkersCount}const computedPoints=cacheComputedPointsInChunk(msg.data);const prevCachedCount=windowCalc.passCachedPoints;windowCalc.passTotalPoints+=computedPoints;if(windowCalc.caching){const chunkId=buildChunkId(msg.data.chunkPos);let cacheScan=windowCalc.cacheScannedChunks.get(chunkId);if(cacheScan!==undefined){if(msg.data.results.length===0){msg.data.results=new Array(msg.data.chunkLen)}for(const entry of cacheScan){msg.data.results[entry[0]]=entry[1]}windowCalc.passCachedPoints+=cacheScan.size;windowCalc.cacheScannedChunks.delete(chunkId)}const newlySeenCachedPoints=windowCalc.passCachedPoints-prevCachedCount;windowCalc.passTotalPoints+=newlySeenCachedPoints}if("blaPixelsCount"in msg.data){windowCalc.passBlaPixels+=msg.data.blaPixelsCount;windowCalc.passBlaIterationsSkipped+=msg.data.blaIterationsSkipped;windowCalc.passBlaSkips+=msg.data.blaSkips;windowCalc.totalBlaPixels+=msg.data.blaPixelsCount;windowCalc.totalBlaIterationsSkipped+=msg.data.blaIterationsSkipped;windowCalc.totalBlaSkips+=msg.data.blaSkips}const status={chunks:windowCalc.totalChunks,chunksComplete:windowCalc.chunksComplete,pixelWidth:windowCalc.lineWidth,running:!isImageComplete(),workersCount:workersCountToReport,workersNow:windowCalc.workers.length,passPoints:windowCalc.passTotalPoints,passCachedPoints:windowCalc.passCachedPoints};if(windowCalc.saCoefficients!==null){status.saItersSkipped=windowCalc.saCoefficients.itersToSkip}if(windowCalc.totalBlaPixels!==null&&windowCalc.referenceBlaEpsilon!==null){status.totalBlaPixels=windowCalc.totalBlaPixels;status.totalBlaIterationsSkipped=windowCalc.totalBlaIterationsSkipped;status.totalBlaSkips=windowCalc.totalBlaSkips;status.blaEpsilon=infNumExpStringTruncToLen(windowCalc.referenceBlaEpsilon,2)}msg.data.calcStatus=status;self.postMessage(msg.data)}function isImageComplete(){return windowCalc.chunksComplete===windowCalc.totalChunks&&windowCalc.lineWidth===windowCalc.finalWidth}function shuffleArray(array){for(let i=array.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[array[i],array[j]]=[array[j],array[i]]}}function centerOutArray(array){const newArr=[];while(array.length>0){newArr.push(array.splice(array.length>>1,1)[0])}while(newArr.length>0){array.push(newArr.shift())}}function sortXPixelChunksArray(array){array.sort((function(a,b){return a.chunkPix.x-b.chunkPix.x}))}var calculateWindowPassChunks=function(){windowCalc.passNumber++;windowCalc.passBlaPixels=0;windowCalc.passBlaIterationsSkipped=0;windowCalc.passBlaSkips=0;windowCalc.passTotalPoints=0;windowCalc.passCachedPoints=0;windowCalc.chunksComplete=0;windowCalc.xPixelChunks=[];windowCalc.cacheScannedChunks=new Map;windowCalc.cacheScannedChunksCursor=-1;if(windowCalc.lineWidth===windowCalc.finalWidth){return}const potentialTempLineWidth=Math.round(windowCalc.lineWidth/2);if(potentialTempLineWidth<=windowCalc.finalWidth){windowCalc.lineWidth=windowCalc.finalWidth}else{windowCalc.lineWidth=potentialTempLineWidth}sendStatusMessage("Calculating pixels for "+windowCalc.lineWidth+"-wide pass");const pixelSize=windowCalc.lineWidth;const skipPrevPixels=!windowCalc.caching&&windowCalc.passNumber>startPassNumber;const yPointsPerChunk=Math.ceil(windowCalc.canvasHeight/pixelSize)+1;const yPointsPerChunkHalf=Math.ceil(yPointsPerChunk/2);const isBasic=windowCalc.algorithm.includes("basic");const incX=windowCalc.math.mul(windowCalc.eachPixUnitsM,windowCalc.math.createFromNumber(pixelSize));const incXTwice=windowCalc.math.mul(incX,windowCalc.math.createFromNumber(2));const zero=windowCalc.math.createFromNumber(0);let cursorX,yBottom;if(isBasic){cursorX=structuredClone(windowCalc.edgesM.left);yBottom=structuredClone(windowCalc.edgesM.bottom)}else{cursorX=structuredClone(windowCalc.referenceBottomLeftDeltaX);yBottom=structuredClone(windowCalc.referenceBottomLeftDeltaY)}const yBottomSkip=windowCalc.math.add(yBottom,incX);let chunkNum=0;for(let x=0;x<windowCalc.canvasWidth;x+=pixelSize){let chunk={plot:windowCalc.plot,chunkN:windowCalc.n,chunkPrecision:windowCalc.precision};if(skipPrevPixels&&chunkNum%2==0){Object.assign(chunk,{chunkPix:{x:x,y:windowCalc.canvasHeight-pixelSize},chunkPixInc:{x:0,y:-2*pixelSize},chunkPos:{x:structuredClone(cursorX),y:structuredClone(yBottomSkip)},chunkInc:{x:structuredClone(zero),y:structuredClone(incXTwice)},chunkLen:yPointsPerChunkHalf})}else{Object.assign(chunk,{chunkPix:{x:x,y:windowCalc.canvasHeight},chunkPixInc:{x:0,y:-1*pixelSize},chunkPos:{x:structuredClone(cursorX),y:structuredClone(yBottom)},chunkInc:{x:structuredClone(zero),y:structuredClone(incX)},chunkLen:yPointsPerChunk})}windowCalc.xPixelChunks.push(chunk);cursorX=windowCalc.math.add(cursorX,incX);chunkNum++}if(windowCalc.chunkOrdering=="random"){shuffleArray(windowCalc.xPixelChunks)}else if(windowCalc.chunkOrdering=="center first"){centerOutArray(windowCalc.xPixelChunks)}windowCalc.totalChunks=windowCalc.xPixelChunks.length};function updateRunningChunksOrdering(){if(windowCalc.chunkOrdering=="random"){shuffleArray(windowCalc.xPixelChunks)}else if(windowCalc.chunkOrdering=="center first"){sortXPixelChunksArray(windowCalc.xPixelChunks);centerOutArray(windowCalc.xPixelChunks)}else{sortXPixelChunksArray(windowCalc.xPixelChunks)}}function sendStatusMessage(message){self.postMessage({plotId:windowCalc.plotId,statusMessage:message})}function setMinibrotNucleusMessage(data){self.postMessage({plotId:windowCalc.plotId,minibrotNucleusFound:data})}function sendDebugPointsMessage(data){self.postMessage({plotId:windowCalc.plotId,debugPoints:data})}function cleanUpWindowCache(){if(!windowCalc.caching){return}let cachedPointsDeleted=0;let cachedPointsKept=0;let cachedPxToDelete=[];let px=null;let py=null;for(const pxEntry of windowCalc.pointsCache){px=createInfNumFromFastStr(pxEntry[0]);if(infNumLt(px,windowCalc.edges.left)||infNumGt(px,windowCalc.edges.right)){cachedPxToDelete.push(pxEntry[0]);cachedPointsDeleted+=pxEntry[1].size}else{let cachedPyToDelete=[];for(const pyStr of pxEntry[1].keys()){py=createInfNumFromFastStr(pyStr);if(infNumLt(py,windowCalc.edges.bottom)||infNumGt(py,windowCalc.edges.top)){cachedPyToDelete.push(pyStr)}else{cachedPointsKept++}}for(const pyStr of cachedPyToDelete){pxEntry[1].delete(pyStr)}cachedPointsDeleted+=cachedPyToDelete.length}}for(const px of cachedPxToDelete){windowCalc.pointsCache.delete(px)}const deletedPct=Math.round(cachedPointsDeleted*1e4/(cachedPointsDeleted+cachedPointsKept))/100;console.log("deleted ["+cachedPointsDeleted+"] points from the cache ("+deletedPct+"%)")}