<!DOCTYPE html>
<!--

genetic algorithm for improving a Mancala-playing NN:
- run a large tournament of NNs
- the 4 best in each tournament are the basis for half the entrants in the next tournament
- after each tournament, the winner NN is output to the screen for saving

-->
<html>
	<head>
		<script src="../p5-v1.9.0.min.js"></script>
		<script src="neural-network-model-ga-1710871875.js"></script>
		<script>
const dispWidth = 1100;
const dispHeight = dispWidth * .38;
const roundRectRadius = dispWidth * .05;
const padding = 22;
const pitsPerSide = 6;
const pitWidth = (dispWidth - (padding * (pitsPerSide + 2 + 1))) / (pitsPerSide + 2);
const pitHeight = (dispHeight - (padding * 3)) / 2;
const seedSize = 16;
let boardColor;
let pitColors = [];
let seedColors = [];
let seedColor;
let seedsInHand = [];
let destinationPitIndexes = [];

const WAITING_FOR_PLAYER = 0;
const PIECES_MOVING_FROM_HAND = 1;
const PIECES_MOVING_TO_BANK = 2;
const ADJUSTING_NEURAL_NETWORK_WEIGHTS = 10;
const GAME_OVER = -1;
const CANCEL_EVERYTHING = -100;
let donePrintingCancelOutput = false;
const SIMULATION_CTX = {
	'ownBank': null,
	'oppBank': null,
	'matchesToPlayPerPair': 1, // can probably remove this and do something else, but it'll change fewer lines to just use this for now
	'pitWinProbability': null,
	'matchHasStarted': false,
	'gamesPlayed': 0.0,
	'idxZeroNetGamesWon': 0.0
};
let currentPlayerTurn = 0;
let currentState = WAITING_FOR_PLAYER;
let movingSeed = null;
const HUMAN_PLAYER_INDEX = -1;
const ML_PLAYER_NN_BY_INDEX = {
	0: null,
	1: null
};

let runningSimulation = false;
let modelOutputParagraph;
let statusParagraph;
let gamesToSimulatePerMatchup = 21; // odd number
let logMatchupsAndResults = false; // hashing the NNs really slows down generating a new batch of NNs for a new tournament

let tournamentNextRound = [];
let tournamentCurrRound = [];
let tournamentBest = [];
let tournamentsCompleted = 0;
let numberOfTournamentsToRun = 999;
let tournamentFinalistsToKeep = 4; // some power of 2

const INITIAL_SEEDS_IN_PIT = 4;
const pits = [];
let capturedPits = [];

let fpsParagraph;
let fpsLastTime = 0;
const ANIMATION_FPS = 90;
const STILL_FPS = 1;


// thanks to https://gist.github.com/vaiorabbit/5657561
// 32 bit FNV-1a hash
// Ref.: http://isthe.com/chongo/tech/comp/fnv/
const FNV1_32A_INIT = 0x811c9dc5;
function fnv32a(str) {
	let hval = FNV1_32A_INIT;
	for (let i = 0; i < str.length; ++i) {
		hval ^= str.charCodeAt(i);
		hval += (hval << 1) + (hval << 4) + (hval << 7) + (hval << 8) + (hval << 24);
	}
	return hval >>> 0;
}
// version of above FNV-1a that doesn't take string
//   input -- instead it takes one 32-bit input,
//   mixes in each byte separately, and returns another
//   32-bit output
const MASK_32B_1 = 0b11111111000000000000000000000000;
const MASK_32B_2 = 0b00000000111111110000000000000000;
const MASK_32B_3 = 0b00000000000000001111111100000000;
const MASK_32B_4 = 0b00000000000000000000000011111111;
function fnv32a_32bitint(int32b) {
	let hval = FNV1_32A_INIT;
	hval ^= (int32b & MASK_32B_1);
	hval += (hval << 1) + (hval << 4) + (hval << 7) + (hval << 8) + (hval << 24);
	hval ^= (int32b & MASK_32B_2);
	hval += (hval << 1) + (hval << 4) + (hval << 7) + (hval << 8) + (hval << 24);
	hval ^= (int32b & MASK_32B_3);
	hval += (hval << 1) + (hval << 4) + (hval << 7) + (hval << 8) + (hval << 24);
	hval ^= (int32b & MASK_32B_4);
	hval += (hval << 1) + (hval << 4) + (hval << 7) + (hval << 8) + (hval << 24);
	return hval >>> 0;
}
function test_fnv32a_32bitint() {
	const buckets = [];
	for (let i = 0; i <= 10; i++) {
		buckets.push(0);
	}
	for (let i = 0; i < 10000; i++) {
		buckets[Math.floor(fasterRandom(0,10))] += 1;
	}
	console.log("random values 0-10, Math.floor(), then placed in buckets: [" + buckets + "]");
}
// this appears to confirm FNV-1a doesn't repeat itself
//   after 100 million iterations
function test_fnv32a_repeat(iters) {
	const origHash = fnv32a(str(Date.now()));
	let newHash = fnv32a_32bitint(origHash);
	for (let i = 0; i < iters-1; i++) {
		if (newHash === origHash) {
			console.log("repeat hash DETECTED after [" + (i+1) + "] iterations");
			return;
		}
		newHash = fnv32a_32bitint(origHash);
	}
	console.log("repeat hash not detected after [" + iters + "] iterations");
}

let fasterRandomUsage = 2000000;
let fasterRandomHash = null;
// since bit shifting clamps number values to 32-bit unsigned
//   values, the maximum value the hash can have is this
//   BUT since we want the upper bound to be exclusive, we'll
//   add one to this
const MAX_UNSIGNED_HASH = (0b11111111111111111111111111111111) + 1;
function fasterRandom(minInclusive, maxExclusive) {
	if (fasterRandomUsage++ > 1000000) {
		fasterRandomUsage = 0;
		fasterRandomHash = fnv32a(str(Date.now()));
		//console.log("re-seeded FNV-1a PRNG with the current time");
	}
	fasterRandomHash = fnv32a_32bitint(fasterRandomHash);
	const valueAsFrac = fasterRandomHash / MAX_UNSIGNED_HASH;
	return minInclusive + (valueAsFrac * (maxExclusive - minInclusive));
}

// thanks to https://stackoverflow.com/a/36481059/259456
const TWO_PI = 2.0 * Math.PI;
function fasterRandomGaussian(mean, stddev) {
	const u = 1 - fasterRandom(0, 1); // Converting [0,1) to (0,1]
	const v = fasterRandom(0, 1);
	const z = Math.sqrt(-2.0 * Math.log(u)) * Math.cos(TWO_PI * v);
	return (z * stddev) + mean;
}

function createShuffledArray(fromInclusive, toInclusive) {
	const ordered = [];
	for (let i = fromInclusive; i <= toInclusive; i++) {
		ordered.push(i);
	}
	const shuffled = [];
	let idx;
	for (let i = fromInclusive; i <= toInclusive; i++) {
		if (ordered.length == 1) {
			shuffled.push(ordered.pop());
		} else {
			idx = Math.floor(fasterRandom(0, ordered.length));
			shuffled.push(ordered.splice(idx, 1)[0]);
		}
	}
	return shuffled;
}

function swish(input) {
	return input / (1.0 + Math.exp(-input));
}

function swishDerivative(input) {
	const exp = Math.exp(-input);
	return (1 + exp + (input * exp)) / Math.pow(1 + exp, 2);
}

function sigmoid(input) {
	// sigmoid function, thanks to https://dev.to/venture/writing-a-neural-network-in-javascript-2020-intro-to-neural-networks-2c4n
	return 1.0 / (1.0 + Math.exp(-input));
}

// thanks to https://math.stackexchange.com/questions/78575/derivative-of-sigmoid-function-sigma-x-frac11e-x
function sigmoidDerivative(input) {
	const s = sigmoid(input);
	return s * (1 - s);
}

function leakyRelu(input) {
	return input <= 0 ? 0.05 * input : input;
}

function leakyReluDerivative(input) {
	return input <= 0 ? 0.05 : 1;
}

class Neuron {
	constructor(weights, bias_input) {
		this.weights = weights; // an array of floats
		this.bias_input = bias_input; // a number
	}

	process_input(inputs) {
		// start with the bias_input
		let sum = this.bias_input;
		// mulitply each input by its (corresponding by array position) weight
		inputs.forEach((value, index) => sum += value * this.weights[index]);
		// sigmoid function, thanks to https://dev.to/venture/writing-a-neural-network-in-javascript-2020-intro-to-neural-networks-2c4n
		//return 1.0 / (1.0 + Math.exp(-sum));
		//return sigmoid(sum);
		//return swish(sum);
		return leakyRelu(sum);
	}

	mutate(pctToChange, doUniform) {
		for (let i = 0; i < this.weights.length; i++) {
			if (fasterRandom(0.0, 1.0) > pctToChange) {
				continue;
			}
			let factor = doUniform ? fasterRandom(0.9, 1.1) : fasterRandomGaussian(0.0, 0.05);
			// most of the time, don't flip the sign
			if (fasterRandom(0.0, 1.0) < 0.2) {
				factor = -factor;
			}
			this.weights[i] *= factor;
		}
		// leave 80% of the biases unchanged
		if (fasterRandom(0.0, 1.0) < 0.8) {
			return;
		}
		let biasFactor = doUniform ? fasterRandom(0.9, 1.1) : fasterRandomGaussian(0.0, 0.05);
		// since the bias can be negative, occasionally flip its sign
		if (fasterRandom(0.0, 1.0) < 0.2) {
			biasFactor = -biasFactor;
		}
		this.bias_input *= biasFactor;
	}
}

class NeuronLayer {
	constructor(neurons, numberOfInputs, json = null) {
		if (json !== null) {
			this.numberOfInputs = json.numberOfInputs;
			this.neurons = [];
			for (let i = 0; i < json.neuronWeights.length; i++) {
				this.neurons.push(new Neuron(json.neuronWeights[i], json.neuronBias[i]));
			}
		} else {
			// initialize with random weights and biases
			// https://www.youtube.com/watch?v=8krd5qKVw-Q
			// - each weight is normally distributed around 0 w/ stanard deviation of 1
			// - then multiply each weight by sqrt(1/n) where n is the number of
			//     neurons in the layer
			const initFactor = Math.sqrt(1/neurons);
			this.numberOfInputs = numberOfInputs;
			this.neurons = [];
			for (let i = 0; i < neurons; i++) {
				let weights = [];
				for (let j = 0; j < numberOfInputs; j++) {
					weights.push(fasterRandomGaussian(0, 1) * initFactor);
				}
				//this.neurons.push(new Neuron(weights, random(-1, 1)));
				// initialize bias to 0 when using gradient descent learning,
				//   but for randomized genetic algorithm approach use
				//   some small value
				this.neurons.push(new Neuron(weights, fasterRandomGaussian(0, 0.1)));
			}
		}
	}

	export_to_json() {
		const json = {
			neuronWeights: [],
			neuronBias: []
		};
		for (const neuron of this.neurons) {
			json.neuronWeights.push(neuron.weights);
			json.neuronBias.push(neuron.bias_input);
		}
		return json;
	}

	process_input(inputs) {
		return this.neurons.map((n) => n.process_input(inputs));
	}

	mutate(pctToChange, doUniform) {
		for (const neuron of this.neurons) {
			neuron.mutate(pctToChange, doUniform);
		}
	}
}

class NeuralNet {
	constructor(json = null, inputs = -1, inputNeurons = -1, hiddenLayerNeurons = -1, hiddenLayers = -1, outputNeurons = -1) {
		if (json !== null) {
			this.restore_from_json(json);
		} else {
			this.inputLayer = new NeuronLayer(inputNeurons, inputs);
			this.hiddenLayers = [];
			for (let i = 0; i < hiddenLayers; i++) {
				const hiddenLayerInputs = i == 0 ? inputNeurons : hiddenLayerNeurons;
				this.hiddenLayers.push(new NeuronLayer(hiddenLayerNeurons, hiddenLayerInputs));
			}
			this.outputLayer = new NeuronLayer(outputNeurons, hiddenLayerNeurons);
			this.generation = 1;
		}
		this.gamesPlayed = 0;
		this.gamesWon = 0;
		this.tournamentsWon = 0;
		if (logMatchupsAndResults) {
			updateHashId();
		} else {
			this.hashId = 0;
		}
	}

	restore_from_json(json) {
		this.inputLayer = new NeuronLayer(-1, -1, json.inputLayer);
		this.hiddenLayers = [];
		for (let i = 0; i < json.hiddenLayers.length; i++) {
			this.hiddenLayers.push(new NeuronLayer(-1, -1, json.hiddenLayers[i]));
		}
		this.outputLayer = new NeuronLayer(-1, -1, json.outputLayer);
		this.generation = json.generation;
	}

	export_to_json() {
		const json = {
			inputLayer: this.inputLayer.export_to_json(),
			hiddenLayers: [],
			outputLayer: this.outputLayer.export_to_json(),
			generation: this.generation,
		};
		for (const layer of this.hiddenLayers) {
			json.hiddenLayers.push(layer.export_to_json());
		}
		return JSON.stringify(json, null, "");
	}

	process_input(inputs) {
		let layerOutput = this.inputLayer.process_input(inputs);
		for (const layer of this.hiddenLayers) {
			layerOutput = layer.process_input(layerOutput);
		}
		return this.outputLayer.process_input(layerOutput);
	}

	mutate(pctToChange, doUniform) {
		this.inputLayer.mutate(pctToChange, doUniform);
		for (const layer of this.hiddenLayers) {
			layer.mutate(pctToChange, doUniform);
		}
		this.outputLayer.mutate(pctToChange, doUniform);
		if (logMatchupsAndResults) {
			updateHashId();
		} else {
			this.hashId = 0;
		}
		this.generation += 1;
	}

	updateHashId() {
		this.hashId = fnv32a(this.export_to_json());
	}

	getHashId() {
		return this.hashId;
	}
}

class SeedMovement {
	constructor(startPos, endPos, seed, destinationPitIndex) {
		this.seed = seed;
		this.startPos = startPos;
		this.endPos = endPos;
		this.destinationPitIndex = destinationPitIndex;
		this.fracComplete = runningSimulation ? 1.0 : 0.0;
		// take about 1/4 second to reach the end position
		this.fracStep = 4.0 / frameRate();
	}

	updateAndDraw() {
		fill(this.seed.color);
		this.fracComplete += this.fracStep;
		if (this.fracComplete > 1.0) {
			this.fracComplete = 1.0;
		}
		circle(lerp(this.startPos.x, this.endPos.x, this.fracComplete), lerp(this.startPos.y, this.endPos.y, this.fracComplete), seedSize);
		return this.fracComplete == 1.0;
	}
}

class Seed {
	constructor(color) {
		this.color = color;
	}
}

class Pit {
	constructor(x, y, width, height, seedCount, doSquareArrangement, playerIndex, isBank, index) {
		this.x = x;
		this.y = y;
		this.width = width;
		this.height = height;
		this.midX = this.x + (this.width / 2);
		this.midY = this.y + (this.height / 2);
		this.seeds = [];
		this.doSquareArrangement = doSquareArrangement;
		this.playerIndex = playerIndex;
		this.isBank = isBank;
		this.index = index;
		this.resetWithNewSeeds(seedCount);
	}

	resetWithNewSeeds(seedCount) {
		this.seeds = [];
		for (let i = 0; i < seedCount; i++) {
			this.seeds.push(new Seed(seedColors[this.playerIndex]));
		}
	}

	drawSeedCount() {
		//fill(pitColors[this.playerIndex]);
		//stroke(220,220,220);
		//strokeWeight(4);
		//fill(boardColor);
		fill(seedColors[this.playerIndex]);
		noStroke();
		textFont('Helvetica');
		textSize(dispWidth * 0.04);
		textAlign(CENTER, CENTER);
		text(this.seeds.length, this.midX, this.y + this.height - 24);
	}

	draw() {
		if (currentPlayerTurn == this.playerIndex) {
			stroke(200,200,200);
			strokeWeight(5);
		} else {
			noStroke();
		}
		fill(pitColors[this.playerIndex]);
		rect(this.x, this.y, this.width, this.height, roundRectRadius);
		noStroke();
		fill(seedColor);
		drawSeeds(this.midX, this.midY, this.seeds, this.doSquareArrangement);
	}

	wasClicked(clickX, clickY) {
		return currentState == WAITING_FOR_PLAYER && !this.isBank &&
			currentPlayerTurn == this.playerIndex &&
			this.seeds.length > 0 &&
			clickX > this.x && clickX < (this.x + this.width) &&
			clickY > this.y && clickY < (this.y + this.height);
	}

	getNextSeedPos() {
		return drawSeeds(this.midX, this.midY, this.seeds, this.doSquareArrangement, true);
	}

	getLastSeedPos() {
		return drawSeeds(this.midX, this.midY, this.seeds, this.doSquareArrangement, false);
	}

	addSeed(seed) {
		this.seeds.push(seed);
	}
}

function setup() {
	frameRate(STILL_FPS);
	noStroke();
	boardColor = color(50,50,50);
	pitColors[0] = color(150,130,130);
	seedColors[0] = color(170,85,85);
	pitColors[1] = color(130,130,150);
	seedColors[1] = color(85,85,170);
	seedColor = color(150,150,150);
	createCanvas(dispWidth, dispHeight);
	//let pitX = padding + pitWidth + padding;
	let pitX = padding;
	for (let i = 0; i < (pitsPerSide * 2) + 2; i++) {
		// left-hand side large "bank" pit
		if (i == 0) {
			pits.push(new Pit(pitX, padding, pitWidth, dispHeight - padding - padding, 0, false, 1, true, i));
			pitX += padding + pitWidth;

		// right-hand side large "bank" pit
		} else if (i == pitsPerSide + 1) {
			pits.push(new Pit(pitX, padding, pitWidth, dispHeight - padding - padding, 0, false, 0, true, i));
			pitX -= padding + pitWidth;

		// bottom row of pits
		} else if (i <= pitsPerSide) {
			pits.push(new Pit(pitX, padding + pitHeight + padding, pitWidth, pitHeight, INITIAL_SEEDS_IN_PIT, true, 0, false, i));
			pitX += padding + pitWidth;

		// top row of pits
		} else {
			pits.push(new Pit(pitX, padding, pitWidth, pitHeight, INITIAL_SEEDS_IN_PIT, true, 1, false, i));
			pitX -= padding + pitWidth;
		}
	}
	fpsParagraph = createElement('p');
	statusParagraph = createElement('p');
	modelOutputParagraph = createElement('p');
	
	// reconstruct neural network(s) from previously-exported json
	populateCurrRoundBasedOnNN(new NeuralNet(json = BEST_NN_MODEL));
	// flesh out initial smaller tournament
	for (let i = 0; i < 128 - tournamentCurrRound.length; i++) {
		tournamentCurrRound.push(createRandomizedNN());
	}
	populateCurrRoundWithRandomNNs();
	tournamentRoundStartingSize = tournamentCurrRound.length;
	beginNewMatchupFromCurrentRound();
}

function beginNewMatchupFromCurrentRound() {
	ML_PLAYER_NN_BY_INDEX[0] = tournamentCurrRound.splice(Math.floor(fasterRandom(0, tournamentCurrRound.length)), 1)[0];
	ML_PLAYER_NN_BY_INDEX[1] = tournamentCurrRound.splice(Math.floor(fasterRandom(0, tournamentCurrRound.length)), 1)[0];
	runningSimulation = false;
	currentState == GAME_OVER;
	SIMULATION_CTX.matchHasStarted = false;
}

function createRandomizedNN() {
	return new NeuralNet(json = null, inputs = (pitsPerSide*2)+6, inputNeurons = (pitsPerSide*2)+6,
		hiddenLayerNeurons = fasterRandom(100, 300),
		hiddenLayers = fasterRandom(3, 8),
		outputNeurons = pitsPerSide);
}

function drawBoard() {
	noStroke();
	background(120,120,120);
	fill(boardColor);
	rect(0, 0, width, height, roundRectRadius);

	for (const pit of pits) {
		pit.draw();
		if (currentPlayerTurn < 0 && pit.isBank) {
			pit.drawSeedCount();
		}
	}
}

function shouldTurn(doSquareArrangement, i) {
	if (doSquareArrangement) {
		return [1,2,4,6,9,12,16,20,25,30,36,42,49,56,64,72,81].indexOf(i) > -1;
	} else {
		return [0,3,4,8,10,15,18,24,28,35,40,48,54,63,70,80,88,99].indexOf(i) > -1;
	}
}

function drawSeeds(atPosX, atPosY, seeds, doSquareArrangement, onlyGetNextPos = false) {
	let xPos = atPosX;
	let yPos = atPosY;
	let stepAngle = 0;
	let xStep = seedSize * cos(stepAngle);
	let yStep = seedSize * sin(stepAngle);
	let lastX = 0;
	let lastY = 0;
	for (let i = 0; i < seeds.length; i++) {
		if (!onlyGetNextPos) {
			fill(seeds[i].color);
			circle(xPos, yPos, seedSize);
		}
		lastX = xPos;
		lastY = yPos;
		//fill(0,0,0);
		//textSize(10);
		//textAlign(CENTER, CENTER);
		//text(""+i, xPos, yPos);
		const ithSqrt = Math.sqrt(i+1);
		// turn 1/4 turn on square numbered seeds
		//if (Math.floor(ithSqrt) == ithSqrt) {
		if (shouldTurn(doSquareArrangement, i)) {
			stepAngle += (PI/2);
			xStep = seedSize * cos(stepAngle);
			yStep = seedSize * sin(stepAngle);
		}
		xPos += xStep;
		yPos += yStep;
	}
	if (onlyGetNextPos) {
		return createVector(xPos, yPos);
	} else {
		return createVector(lastX, lastY);
	}
}

// draw the number of held seeds
function drawHand() {
	//cursor(HAND);
	//stroke(255,255,255,60);
	//fill(200,70,70,70);
	//textSize(100);
	//textAlign(CENTER, CENTER);
	//text('×', mouseX, mouseY);
	return drawSeeds(mouseX, mouseY, seedsInHand, true);
}

function printModelToScreen(neuralNetwork) {
	// output the neural network weights
	neuralNetwork.updateHashId();
	modelOutputParagraph.html("best nn model after " + tournamentsCompleted + " tournaments:" +
		"<br/>hashId: " + neuralNetwork.getHashId() +
		"<br/>generation: " + neuralNetwork.generation +
		"<br/>hidden layers: " + neuralNetwork.hiddenLayers.length +
		"<br/>neurons per hidden layer: " + neuralNetwork.hiddenLayers[0].neurons.length +
		"<br/>gamesPlayed: " + neuralNetwork.gamesPlayed +
		"<br/>gamesWon: " + neuralNetwork.gamesWon + " (" + roundToDecimalPlaces((neuralNetwork.gamesWon * 100.0) / neuralNetwork.gamesPlayed, 3) + "%)" +
		"<br/>tournamentsWon: " + neuralNetwork.tournamentsWon);
	modelOutputParagraph.html(modelOutputParagraph.html() + '<br/><br/>const BEST_NN_MODEL = ' + neuralNetwork.export_to_json() + ';');
}

function playerTurnIsOver() {
	currentState = WAITING_FOR_PLAYER;
	//frameRate(STILL_FPS);
	// XOR with 1 to alternate between 1 and 0
	currentPlayerTurn = currentPlayerTurn ^ 1;
	// check end game: if the player has no pits with seeds,
	//   the other player captures all their pits' seeds
	let somePitHasSeeds = false;
	for (const pit of pits) {
		if (pit.playerIndex == currentPlayerTurn && !pit.isBank && pit.seeds.length > 0) {
			somePitHasSeeds = true;
			break;
		}
	}
	if (!somePitHasSeeds) {
		// if neither player has any seeds in their pits, the game is over
		let gameIsOver = true;
		for (const pit of pits) {
			if (!pit.isBank && pit.seeds.length > 0) {
				gameIsOver = false;
				break;
			}
		}
		if (gameIsOver) {
			currentState = GAME_OVER;
			//frameRate(STILL_FPS);
			currentPlayerTurn = -1;

			if (!runningSimulation) {
				console.log("ERROR this should never happen, because we are only simulating games here");
				currentState = CANCEL_EVERYTHING;
				frameRate(STILL_FPS);
				return;
			}
		} else {
			currentState = PIECES_MOVING_TO_BANK;
			frameRate(ANIMATION_FPS);
			capturedPits = [];
			for (const pit of pits) {
				if (pit.playerIndex != currentPlayerTurn && !pit.isBank && pit.seeds.length > 0) {
					capturedPits.push(pit);
				}
			}
			// XOR with 1 to alternate between 1 and 0
			currentPlayerTurn = currentPlayerTurn ^ 1;
		}
	}
}

function draw() {
	if (currentState == CANCEL_EVERYTHING) {
		frameRate(STILL_FPS);
		if (!donePrintingCancelOutput) {
			statusParagraph.html("stopped");
			donePrintingCancelOutput = true;
		}
		return;
	}
	// only draw the board on rare occasions... perhaps instead we should
	//   just simulate 100 or 1000 games for every frame
	if (fasterRandom(0.0,1.0) < 0.001) {
		statusParagraph.html("round of " + tournamentRoundStartingSize + " has " + tournamentCurrRound.length + " yet to play");
		drawBoard();
	}
	const lastSeedInHandPos = drawHand();
	if (currentState == PIECES_MOVING_FROM_HAND) {
		if (movingSeed === null) {
			if (seedsInHand.length > 0) {
				const destinationPitIndex = destinationPitIndexes.shift();
				const destinationPos = pits[destinationPitIndex].getNextSeedPos();
				movingSeed = new SeedMovement(lastSeedInHandPos, destinationPos, seedsInHand.pop(), destinationPitIndex);
			} else {
				playerTurnIsOver();
			}
		}
		if (movingSeed !== null) {
			const doneMoving = movingSeed.updateAndDraw();
			if (doneMoving) {
				const destPit = pits[movingSeed.destinationPitIndex];
				destPit.addSeed(movingSeed.seed);
				movingSeed = null;
				// if this moved seed was the last seed in the hand,
				//   check if the destination pit is owned by the
				//   moving player and has only 1 seed.  if so, then
				//   that player captures that seed and all the seeds
				//   in the opposite pit.
				if (seedsInHand.length === 0 && destPit.playerIndex == currentPlayerTurn) {
					// if the last seed is placed in the player's bank, that
					//   player gets another turn
					if (destPit.isBank) {
						// switch player here, then immediately switch again
						//   in playerTurnIsOver() -- this is needed in case
						//   the player ends in their bank but has no remaining
						//   seeds (playerTurnIsOver() will end the game)
						currentPlayerTurn = currentPlayerTurn ^ 1;
						playerTurnIsOver();
					} else if (destPit.seeds.length === 1) {
						capturedPits = [destPit];
						const rightHandBankIndex = pitsPerSide + 1;
						// if the pit index is less than the midpoint of the pits array, it's
						//   in the bottom row
						if (destPit.index < pits.length / 2) {
							const distToMidBank = rightHandBankIndex - destPit.index;
							const oppositePitIndex = rightHandBankIndex + distToMidBank;
							capturedPits.push(pits[oppositePitIndex]);
						} else {
							const distToMidBank = destPit.index - rightHandBankIndex;
							const oppositePitIndex = rightHandBankIndex - distToMidBank;
							capturedPits.push(pits[oppositePitIndex]);
						}
						currentState = PIECES_MOVING_TO_BANK;
						frameRate(ANIMATION_FPS);
					}
				}
			}
		}
	} else if (currentState == PIECES_MOVING_TO_BANK) {
		// similar to "moving from hand" state
		const destBankPitIndex = currentPlayerTurn == 1 ? 0 : pitsPerSide + 1;
		if (movingSeed === null) {
			if (capturedPits.length > 0 && capturedPits[0].seeds.length > 0) {
				const startPos = capturedPits[0].getLastSeedPos();
				const destinationPos = pits[destBankPitIndex].getNextSeedPos();
				movingSeed = new SeedMovement(startPos, destinationPos, capturedPits[0].seeds.pop(), destBankPitIndex);
			} else if (capturedPits.length > 1 && capturedPits[1].seeds.length > 0) {
				capturedPits.shift();
			} else {
				playerTurnIsOver();
			}
		}
		if (movingSeed !== null) {
			const doneMoving = movingSeed.updateAndDraw();
			if (doneMoving) {
				const destPit = pits[movingSeed.destinationPitIndex];
				destPit.addSeed(movingSeed.seed);
				movingSeed = null;
			}
		}
	} else if (currentState == WAITING_FOR_PLAYER && ML_PLAYER_NN_BY_INDEX[currentPlayerTurn] !== null) {
		playAITurnOrStartTraining();
	} else if (currentState == GAME_OVER && runningSimulation) {
		playAITurnOrStartTraining();
	}
	//if (fasterRandom(0,10) < 1.0) {
	//	const fpsTimeEpochMs = Date.now();
	//	if (fpsTimeEpochMs - fpsLastTime > 1000) {
	//		fpsLastTime = fpsTimeEpochMs;
	//		fpsParagraph.html(round(frameRate()));
	//	}
	//}
}

function selectPitForPlay(pit) {
	seedsInHand = pit.seeds;
	pit.seeds = [];
	currentState = PIECES_MOVING_FROM_HAND;
	frameRate(ANIMATION_FPS);
	destinationPitIndexes = [];
	let pitCursor = pit.index;
	for (let i = 0; i < seedsInHand.length; i++) {
		pitCursor += 1;
		if (pitCursor >= pits.length) {
			pitCursor = 0;
		}
		if (pits[pitCursor].isBank && pits[pitCursor].playerIndex != currentPlayerTurn) {
			i -= 1; // re-do this seed if we have to skip the other player's bank
			continue;
		}
		destinationPitIndexes.push(pitCursor);
	}
}

// 0 13 12 11 10  9  8
//    1  2  3  4  5  6  7
const TOTAL_SEEDS_OVERALL = INITIAL_SEEDS_IN_PIT * pitsPerSide * 2;
function getNNInputs() {
	// ensure inputs are normalized from 0.0-1.0 (where we divide the number of seeds per pit by 48, the overall number of seeds)
	let inputs = pits.map((pit) => pit.seeds.length / TOTAL_SEEDS_OVERALL);
	// if currentPlayerTurn == 1, we need to swap the inputs around so player
	//   1 gets the same inputs that player 0 would get
	if (currentPlayerTurn == 1) {
		// start with the opponent's bank
		let swappedInputs = [inputs[pitsPerSide+1]];
		// then do own pits
		// use strange "spread syntax" to concat the slice onto the end of the existing array
		swappedInputs.push(...inputs.slice(pitsPerSide+2, pitsPerSide+pitsPerSide+2));
		// then do own bank
		swappedInputs.push(inputs[0]);
		// finally, do oppoent's pits
		swappedInputs.push(...inputs.slice(1, pitsPerSide+1));
		inputs = swappedInputs;
	}
	// also add inputs for each player's total number of seeds
	playerSeeds = [0, 0];
	pits.forEach((pit) => playerSeeds[pit.playerIndex] += pit.seeds.length);
	// XOR with currentPlayerTurn to swap 0 and 1 if currentPlayerTurn == 1
	inputs.push(playerSeeds[0 ^ currentPlayerTurn] / TOTAL_SEEDS_OVERALL);
	inputs.push(playerSeeds[1 ^ currentPlayerTurn] / TOTAL_SEEDS_OVERALL);
	// also add inputs for each player's total number of non-bank seeds
	playerNonBankSeeds = [0, 0];
	pits.forEach((pit) => playerNonBankSeeds[pit.playerIndex] += pit.isBank ? 0 : pit.seeds.length);
	inputs.push(playerNonBankSeeds[0 ^ currentPlayerTurn] / TOTAL_SEEDS_OVERALL);
	inputs.push(playerNonBankSeeds[1 ^ currentPlayerTurn] / TOTAL_SEEDS_OVERALL);
	return inputs;
}

function populateCurrRoundBasedOnNN(nn) {
	tournamentCurrRound.push(nn);
	let nnJson = JSON.parse(nn.export_to_json());
	for (let i = 0; i < 32; i++) {
		let mutation = new NeuralNet(json = nnJson);
		mutation.mutate(0.1, true); // uniform
		tournamentCurrRound.push(mutation);
	}
	console.log("initialized " + tournamentCurrRound.length + " NNs including and based on " + tournamentFinalistsToKeep + " finalists");
	for (let i = 0; i < 32; i++) {
		let mutation = new NeuralNet(json = nnJson);
		mutation.mutate(0.1, false); // gaussian
		tournamentCurrRound.push(mutation);
	}
	console.log("initialized " + tournamentCurrRound.length + " NNs including and based on " + tournamentFinalistsToKeep + " finalists");
	for (let i = 0; i < 31; i++) {
		let mutation = new NeuralNet(json = nnJson);
		mutation.mutate(0.2, true); // uniform
		tournamentCurrRound.push(mutation);
	}
	console.log("initialized " + tournamentCurrRound.length + " NNs including and based on " + tournamentFinalistsToKeep + " finalists");
	for (let i = 0; i < 31; i++) {
		let mutation = new NeuralNet(json = nnJson);
		mutation.mutate(0.2, false); // gaussian
		tournamentCurrRound.push(mutation);
	}
	console.log("initialized " + tournamentCurrRound.length + " NNs including and based on " + tournamentFinalistsToKeep + " finalists");
	let mutation = new NeuralNet(json = nnJson);
	mutation.mutate(0.5, true); // uniform
	tournamentCurrRound.push(mutation);
}

function populateCurrRoundWithRandomNNs() {
	// 50% of next tournament entrants are all random
	const basedOnPrevCount = tournamentCurrRound.length;
	console.log("completed initializaing " + basedOnPrevCount + " NNs including and based on " + tournamentFinalistsToKeep + " finalists");
	for (let i = 0; i < basedOnPrevCount; i++) {
		tournamentCurrRound.push(createRandomizedNN());
		if (i % 32 == 0) {
			console.log("initialized " + tournamentCurrRound.length + " NNs including new random NNs for next tournament");
		}
	}
	console.log("completed initializaing " + tournamentCurrRound.length + " NNs including new random NNs for next tournament");
}

function playAITurnOrStartTraining() {
	// if training this AI player, simulate the rest of the game
	//   based on selecting each valid pit
	if (!runningSimulation && currentPlayerTurn >= 0) {//TRAIN_ML_PLAYER_INDEXES.indexOf(currentPlayerTurn) > -1) {

		// start a new simulated game
		if (SIMULATION_CTX.matchHasStarted == false) {
			SIMULATION_CTX.ownBank = pits.filter((p) => p.playerIndex == 0 && p.isBank)[0];
			SIMULATION_CTX.oppBank = pits.filter((p) => p.playerIndex == 1 && p.isBank)[0];
			SIMULATION_CTX.gamesPlayed = 0.0;
			SIMULATION_CTX.idxZeroNetGamesWon = 0.0;
			runningSimulation = true;
			currentState = GAME_OVER; // set runningSimulation AND GAME_OVER to kick off the simulations below
			return;
		}

		// once we get to this point, we advance through tournament:
		// - play each pair in tournamentCurrRound, and advance winner to tournamentNextRound
		// - after tournamentCurrRound is empty, set tournamentNextRound->tournamentCurrRound
		// - once tournamentCurrRound contains only 4 entrants, copy to tournamentBest
		// - once tournamentNextRound has 1 entrant, output that entrant to the screen
		// - to start new tournament, use tournamentBest, spawn more random entrants, then shuffle them all

		// move winner to next round of tournament
		if (SIMULATION_CTX.idxZeroNetGamesWon > 0) {
			if (logMatchupsAndResults) {
				console.log("[" + ML_PLAYER_NN_BY_INDEX[0].getHashId() + "] wins");
			}
			tournamentNextRound.push(ML_PLAYER_NN_BY_INDEX[0]);
		} else if (SIMULATION_CTX.idxZeroNetGamesWon < 0) {
			tournamentNextRound.push(ML_PLAYER_NN_BY_INDEX[1]);
			if (logMatchupsAndResults) {
				console.log("[" + ML_PLAYER_NN_BY_INDEX[1].getHashId() + "] wins");
			}
		} else {
			console.log("ERROR: two contentestants have won an equal number of games, which should be impossible");
			currentState = CANCEL_EVERYTHING;
			frameRate(STILL_FPS);
			return;
		}

		// the current round of the tournament has entrants yet to play
		if (tournamentCurrRound.length > 0) {
			beginNewMatchupFromCurrentRound();

		// the current round of the tournament is done
		} else {
			console.log("the round is complete");
			// the entire tournament is done
			if (tournamentNextRound.length == 1) {
				console.log("the tournament is complete");
				tournamentsCompleted += 1;
				tournamentNextRound[0].tournamentsWon += 1;
				printModelToScreen(tournamentNextRound[0]);
				// optionally stop after some number of tournaments
				if (tournamentsCompleted >= numberOfTournamentsToRun) {
					currentState = CANCEL_EVERYTHING;
					frameRate(STILL_FPS);
					console.log("completed " + tournamentsCompleted + " tournaments");
					return;
				}
				// re-populate the entrants and start the next tournament
				tournamentNextRound = [];
				tournamentCurrRound = [];
				for (const finalist of tournamentBest) {
					populateCurrRoundBasedOnNN(finalist);
				}
				populateCurrRoundWithRandomNNs();
				tournamentRoundStartingSize = tournamentCurrRound.length;
				beginNewMatchupFromCurrentRound();


			// proceed to the next round
			} else if (tournamentNextRound.length > 1) {
				console.log("starting next round with " + tournamentNextRound.length + " entrants remaining");
				tournamentCurrRound = tournamentNextRound;
				tournamentNextRound = [];
				// save finalists if we have reached that point
				if (tournamentCurrRound.length == tournamentFinalistsToKeep) {
					tournamentBest = [];
					tournamentCurrRound.forEach(v => tournamentBest.push(v));
				}
				// somehow reset stuff to begin next round
				tournamentRoundStartingSize = tournamentCurrRound.length;
				beginNewMatchupFromCurrentRound();

			} else if (tournamentNextRound.length == 0) {
				console.log("ERROR: tournamentNextRound has 0 entrants, which should be impossible");
				currentState = CANCEL_EVERYTHING;
				frameRate(STILL_FPS);
				return;
			}
		}

	} else if (runningSimulation && currentState == GAME_OVER) {
		runningSimulation = false;
		// if a simulated game has ended, track the result and restore the state
		if (SIMULATION_CTX.matchHasStarted) {
			SIMULATION_CTX.gamesPlayed += 1.0;
			ML_PLAYER_NN_BY_INDEX[0].gamesPlayed += 1;
			ML_PLAYER_NN_BY_INDEX[1].gamesPlayed += 1;
			//console.log("gamesPlayed=" + SIMULATION_CTX.gamesPlayed);
			if (SIMULATION_CTX.ownBank.seeds.length > SIMULATION_CTX.oppBank.seeds.length) {
				SIMULATION_CTX.idxZeroNetGamesWon += 1.0;
				ML_PLAYER_NN_BY_INDEX[0].gamesWon += 1;
			} else if (SIMULATION_CTX.ownBank.seeds.length < SIMULATION_CTX.oppBank.seeds.length) {
				SIMULATION_CTX.idxZeroNetGamesWon -= 1.0;
				ML_PLAYER_NN_BY_INDEX[1].gamesWon += 1;
			// for a tie, re-play the entire game because we need to have an odd number of non-ties
			} else {
				console.log("tie! re-playing this game");
				SIMULATION_CTX.gamesPlayed -= 1.0;
			}
			// simulate a bunch of games where the next pit is selected
			if (SIMULATION_CTX.gamesPlayed >= gamesToSimulatePerMatchup) {
				if (logMatchupsAndResults) {
					console.log("done simulating " + SIMULATION_CTX.gamesPlayed + " games, idxZeroNetGamesWon=[" + SIMULATION_CTX.idxZeroNetGamesWon + "]");
				}
			}
		// for the initial state, just start the match (match = set of games between the same opponents)
		} else {
			SIMULATION_CTX.matchHasStarted = true;
			if (logMatchupsAndResults) {
				console.log("starting a match between [" + ML_PLAYER_NN_BY_INDEX[0].getHashId() + "] and [" + ML_PLAYER_NN_BY_INDEX[1].getHashId() + "]");
			}
		}
		// restore intial game state
		restartGame();
		// simulate the game again
		if (SIMULATION_CTX.gamesPlayed < gamesToSimulatePerMatchup) {
			frameRate(ANIMATION_FPS);
			runningSimulation = true;
			playAITurn();
			while (currentState != GAME_OVER) {
				draw();
			}
			// return control to the main thread here, after simulating
			//   this game

		// if we are done simulating games for this pair, reset these things
		//   to trigger the simulations for the next pair, but DO NOT
		//   set matchHasStarted = false here, or else we'll
		//   keep simulating these two opponets forever -- set that after playing
		//   the next move
		} else {
			currentState = WAITING_FOR_PLAYER;
			runningSimulation = false;
		}

	// when simulating games, use the board state to select a pit for play
	} else {
		playAITurn();
	}
}

const MOVE_SELECT_EPSILON = 0.001; // one tenth of one percent chance to pick the move (assuming all outputs sum to ~1.0)
function playAITurn() {
	const ai = ML_PLAYER_NN_BY_INDEX[currentPlayerTurn];
	const selectedPitIndexOffset = getPitIndexForNeuralNetworkOutputIndex(0);
	const inputs = getNNInputs();
	// we don't want to get stuck here, so:
	// - replace any output less than some >0 epsilon with epsilon (including any negatives)
	// - replace any output for a pit with 0 seeds with 0
	const outputs = ai.process_input(inputs).map((val,idx) => pits[idx+selectedPitIndexOffset].seeds.length > 0 ? Math.max(MOVE_SELECT_EPSILON, val) : 0.0);
	//if (currentState == ADJUSTING_NEURAL_NETWORK_WEIGHTS) {
	//	console.log("nn outputs are [" + outputs.map((v) => roundToDecimalPlaces(v, 4)) + "]...");
	//}
	// we use each move's probability as the chance to pick that move...
	//   but the probabilities don't necessarily add up to 1.0
	const probSum = outputs.reduce((acc,val) => acc + val);
	const randVal = fasterRandom(0.0, probSum);
	let randReachSum = 0.0;
	let selectedPitIndex = 0;
	for (; selectedPitIndex < outputs.length; selectedPitIndex++) {
		randReachSum += outputs[selectedPitIndex];
		if (randReachSum >= randVal) {
			break;
		}
	}
	//console.log("nn outputs are [" + outputs.map((v,idx) => selectedPitIndex == idx ? "-->" + roundToDecimalPlaces(v, 4) : roundToDecimalPlaces(v, 4)) + "]");
	selectPitForPlay(pits[selectedPitIndex + selectedPitIndexOffset]);
}

// player 0 -> ith pit + 1
// player 1 -> ith pit + 8
function getPitIndexForNeuralNetworkOutputIndex(outputIndex) {
	return outputIndex + 1 + (currentPlayerTurn * (pitsPerSide + 1));
}

function roundToDecimalPlaces(value, decimals) {
	const tenPow = Math.pow(10.0, decimals);
	return Math.round(value * tenPow) / tenPow;
}

function restartGame() {
	for (const pit of pits) {
		if (pit.isBank) {
			pit.resetWithNewSeeds(0);
		} else {
			pit.resetWithNewSeeds(INITIAL_SEEDS_IN_PIT);
		}
	}

	// randomize player turn
	currentPlayerTurn = round(fasterRandom(0,1));
	currentState = WAITING_FOR_PLAYER;
}

		</script>
	</head>
	<body style="background-color: rgb(120,120,120)">
		<main style="text-align:center; padding: 2.0rem;">
		</main>
	</body>
</html>